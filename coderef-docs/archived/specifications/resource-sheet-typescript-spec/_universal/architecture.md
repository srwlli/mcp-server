# Architecture Module

**Type:** Universal (always included)
**Applies to:** All element types
**Auto-fill:** Component hierarchy, dependencies, file structure
**Manual:** Design rationale, architectural patterns

---

## Section: Architecture Overview

### Component Hierarchy

{{AUTO_FILL: element.hierarchy}}

```
{{element.name}}
{{#each element.children}}
├── {{this.name}}
{{#if this.children}}
│   {{#each this.children}}
│   ├── {{this.name}}
│   {{/each}}
{{/if}}
{{/each}}
```

{{MANUAL: Explain the hierarchy design - Why this structure? What are the responsibilities of each component?}}

### File Structure

{{AUTO_FILL: element.file_path}}

**Location:** `{{element.file}}`

**Related Files:**
{{#each element.related_files}}
- `{{this.path}}` - {{this.relationship}}
{{/each}}

{{MANUAL: Explain file organization strategy - Why this location? How does it fit into the project structure?}}

### Dependencies

**Internal Dependencies:**
{{AUTO_FILL: element.imports.filter(imp => imp.isInternal)}}
{{#each element.internal_imports}}
- `{{this.module}}` - {{this.purpose}}
{{/each}}

**External Dependencies:**
{{AUTO_FILL: element.imports.filter(imp => !imp.isInternal)}}
{{#each element.external_imports}}
- `{{this.package}}` ({{this.version}}) - {{this.purpose}}
{{/each}}

{{MANUAL: Explain dependency choices - Why these libraries? Any concerns about dependencies?}}

### Architectural Pattern

{{MANUAL: Identify the architectural pattern used:
- Component-based architecture (React, Vue)
- Service layer pattern (API services)
- Repository pattern (data access)
- Command pattern (CLI tools)
- Factory pattern (generators)
- Singleton pattern (global state)
- Observer pattern (event systems)

Explain why this pattern was chosen and how it benefits the design.}}

### Design Principles

{{MANUAL: List the key design principles followed:
- Single Responsibility
- Open/Closed
- Dependency Inversion
- Composition over Inheritance
- etc.

Explain how these principles are applied in the code.}}

---

## Example Output

### Architecture Overview

#### Component Hierarchy

```
FileTree
├── FileTreeNode (recursive)
│   ├── FileIcon
│   └── ContextMenu
└── LoadingSpinner
```

**Design Rationale:** FileTree delegates node rendering to FileTreeNode for recursive traversal. Each node can render its own children, creating a self-similar tree structure. ContextMenu is owned by FileTreeNode to ensure menu positioning is relative to the clicked node.

#### File Structure

**Location:** `packages/dashboard/src/components/coderef/FileTree.tsx`

**Related Files:**
- `packages/dashboard/src/components/coderef/FileTreeNode.tsx` - Node rendering logic
- `packages/dashboard/src/components/coderef/ContextMenu.tsx` - Right-click menu
- `packages/dashboard/src/types/FileTree.ts` - Type definitions

**Organization Strategy:** Grouped with other coderef components in dedicated folder. Types separated into shared types file for reuse across components.

#### Dependencies

**Internal Dependencies:**
- `./FileTreeNode` - Renders individual tree nodes
- `./ContextMenu` - Provides right-click actions
- `../types/FileTree` - Shared type definitions
- `../../hooks/useLocalStorage` - Persistence for favorites

**External Dependencies:**
- `react` (^18.2.0) - Component framework
- `lucide-react` (^0.263.1) - Icon library for file types

**Dependency Choices:** React is the project framework. Lucide chosen for lightweight, tree-shakeable icons. useLocalStorage hook abstracts persistence to avoid tight coupling to localStorage API.

#### Architectural Pattern

**Pattern:** Component-based architecture with recursive composition

**Rationale:** Tree structures naturally fit recursive rendering. FileTreeNode calls itself for children, avoiding complex iteration logic. This pattern scales well (tested up to 500 nodes) and is easy to extend with new node types.

#### Design Principles

**Principles Applied:**
- **Single Responsibility:** FileTree handles tree state, FileTreeNode handles rendering, ContextMenu handles actions
- **Composition:** Tree built by composing nodes, not inheritance hierarchy
- **Dependency Inversion:** Components depend on interfaces (TreeNode type) not concrete implementations

---

## Metadata

**Generated by:** Resource Sheet MCP Tool
**Module:** architecture (universal)
**Version:** 1.0.0
