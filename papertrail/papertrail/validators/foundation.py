"""
Foundation Document Validator

Validates foundation docs (README, ARCHITECTURE, API, SCHEMA, COMPONENTS)
generated by coderef-docs against foundation-doc-frontmatter-schema.json
"""

from pathlib import Path
from typing import Optional
from .base import BaseUDSValidator
from ..validator import ValidationError, ValidationSeverity


class FoundationDocValidator(BaseUDSValidator):
    """Validates foundation documentation generated by coderef-docs"""

    schema_name = "foundation-doc-frontmatter-schema.json"
    doc_category = "foundation"

    # POWER framework section headers (recommended but not required)
    POWER_SECTIONS = [
        "Purpose",
        "Overview",
        "What",
        "Why",
        "When",
        "Examples",
        "References"
    ]

    def validate_specific(self, frontmatter: dict, content: str, file_path: Optional[Path] = None) -> tuple[list[ValidationError], list[str]]:
        """Foundation-specific validation"""
        errors = []
        warnings = []

        # Check POWER framework sections (recommended)
        missing_power = self._check_power_framework(content)
        if missing_power:
            warnings.append(f"Missing recommended POWER framework sections: {', '.join(missing_power)}")

        # Validate code examples for API and COMPONENTS docs
        doc_type = frontmatter.get('doc_type')
        if doc_type in ['api', 'components']:
            try:
                # Determine project path from file_path if available
                project_path = file_path.parent if file_path else None

                # Call code example validation
                example_errors = self.code_example_validation(frontmatter, content, project_path)
                errors.extend(example_errors)

            except Exception as e:
                # Graceful degradation if code example validation fails
                warnings.append(f"Code example validation skipped: {str(e)}")

        # Check doc_type matches filename if file_path provided
        if file_path:
            expected_type = self._infer_doc_type_from_filename(file_path)
            actual_type = frontmatter.get('doc_type')

            if expected_type and actual_type and expected_type != actual_type:
                errors.append(ValidationError(
                    severity=ValidationSeverity.MAJOR,
                    message=f"doc_type '{actual_type}' doesn't match filename (expected '{expected_type}')",
                    field="doc_type"
                ))

        # Warn if status is DRAFT (should be APPROVED for foundation docs)
        status = frontmatter.get('status')
        if status == 'DRAFT':
            warnings.append("Foundation doc status is DRAFT (should be APPROVED when ready)")

        return (errors, warnings)

    def _check_power_framework(self, content: str) -> list[str]:
        """Check if POWER framework sections are present"""
        missing = []

        for section in self.POWER_SECTIONS:
            # Look for markdown headers with section name
            if f"## {section}" not in content and f"# {section}" not in content:
                missing.append(section)

        return missing

    def _infer_doc_type_from_filename(self, file_path: Path) -> Optional[str]:
        """Infer doc_type from filename"""
        filename = file_path.name.upper()

        if filename == "README.MD":
            return "readme"
        elif filename == "ARCHITECTURE.MD":
            return "architecture"
        elif filename == "API.MD":
            return "api"
        elif filename == "SCHEMA.MD":
            return "schema"
        elif filename == "COMPONENTS.MD":
            return "components"

        return None
