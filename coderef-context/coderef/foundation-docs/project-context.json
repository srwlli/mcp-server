{
  "api_context": {
    "endpoints": [],
    "count": 0,
    "frameworks_detected": [],
    "auth_method": "Unknown",
    "error_format": "RFC 7807"
  },
  "dependencies": {
    "count": 0,
    "production": [],
    "development": [],
    "outdated": [],
    "vulns": []
  },
  "database": {
    "tables": [],
    "relationships": [],
    "migrations": [],
    "table_count": 0,
    "has_migrations": false
  },
  "activity": {
    "recent_commits": [],
    "active_files": [],
    "contributors": [],
    "has_git": false
  },
  "patterns": {
    "handlers": [
      {
        "name": "handle_coderef_scan",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_query",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_impact",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_complexity",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_patterns",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_coverage",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_context",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_validate",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_drift",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_diagram",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_tag",
        "file": "server.py"
      },
      {
        "name": "handle_coderef_export",
        "file": "server.py"
      }
    ],
    "decorators": [
      {
        "name": "pytest.mark.asyncio",
        "count": 92
      },
      {
        "name": "coderef",
        "count": 9
      },
      {
        "name": "pytest.fixture",
        "count": 8
      },
      {
        "name": "staticmethod",
        "count": 3
      },
      {
        "name": "pytest.mark.skip",
        "count": 3
      },
      {
        "name": "app.list_tools",
        "count": 1
      },
      {
        "name": "app.call_tool",
        "count": 1
      },
      {
        "name": "context",
        "count": 1
      }
    ],
    "error_handling": [
      "ValueError",
      "TimeoutError",
      "RuntimeError"
    ]
  },
  "similar_features": [],
  "existing_docs": {
    "architecture": {
      "sections": {
        "architecture_documentation": "**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---",
        "purpose": "This document describes the system architecture of the coderef-context MCP server. It explains the design decisions, module boundaries, data flow, technology stack, and integration points with the broader CodeRef ecosystem.\n\n---",
        "overview": "The coderef-context server is a **Python-based MCP (Model Context Protocol) server** that exposes code intelligence tools from the @coderef/core CLI to AI agents. It acts as a bridge between:\n- **AI Agents** (Claude, GPT, etc.) via MCP protocol\n- **@coderef/core** (TypeScript analysis engine) via Node.js subprocess\n\n**Architecture Style:** Microservice (single-purpose server in multi-server ecosystem)\n**Communication:** Async I/O (stdio-based MCP protocol + subprocess)\n**State Management:** Stateless (no persistent storage)\n\n---",
        "what:_system_topology": "### High-Level Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         AI Agent (Claude)                        \u2502\n\u2502                     (Persona: Ava, Marcus, etc.)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 MCP Protocol (JSON-RPC 2.0)\n                             \u2502 Transport: stdio (stdin/stdout)\n                             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   coderef-context MCP Server                     \u2502\n\u2502                        (Python, asyncio)                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  MCP Server Core (server.py)                             \u2502   \u2502\n\u2502  \u2502  - Tool registration (@app.list_tools)                   \u2502   \u2502\n\u2502  \u2502  - Tool routing (@app.call_tool)                         \u2502   \u2502\n\u2502  \u2502  - Error handling & validation                           \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                             \u2502                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Tool Handlers (11 async functions)                       \u2502  \u2502\n\u2502  \u2502  - handle_coderef_scan                                    \u2502  \u2502\n\u2502  \u2502  - handle_coderef_query                                   \u2502  \u2502\n\u2502  \u2502  - handle_coderef_impact                                  \u2502  \u2502\n\u2502  \u2502  - ... (8 more handlers)                                  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502 Subprocess (asyncio)\n                              \u2502 Commands: CLI_COMMAND + args\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    @coderef/core CLI                             \u2502\n\u2502                   (TypeScript/Node.js)                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  CLI Commands (via dist/cli.js)                          \u2502   \u2502\n\u2502  \u2502  - scan, query, impact, complexity                       \u2502   \u2502\n\u2502  \u2502  - patterns, coverage, context                           \u2502   \u2502\n\u2502  \u2502  - validate, drift, diagram, tag                         \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502 File I/O + AST parsing\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Project Codebase                          \u2502\n\u2502           (TypeScript, JavaScript, React, etc.)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n### Module Boundaries\n\n#### Layer 1: MCP Protocol Layer (server.py)\n**Responsibilities:**\n- Accept MCP tool calls via stdin (JSON-RPC 2.0)\n- Validate input schemas\n- Route to appropriate tool handler\n- Return responses via stdout\n\n**Key Components:**\n- `@app.list_tools()` - Tool registration\n- `@app.call_tool()` - Tool routing\n- `get_cli_command()` - CLI path detection\n\n**Dependencies:** `mcp`, `mcp.server.stdio`\n\n---\n\n#### Layer 2: Tool Handler Layer (server.py:434-1054)\n**Responsibilities:**\n- Parse tool arguments\n- Build CLI commands\n- Execute async subprocess\n- Parse JSON responses\n- Handle errors (timeout, CLI failure, JSON parse)\n\n**Key Components:**\n- 11 async handler functions (handle_coderef_scan, etc.)\n- Shared patterns: async subprocess, timeout, JSON parse\n\n**Dependencies:** `asyncio`, `subprocess`, `json`\n\n---\n\n#### Layer 3: CLI Subprocess Layer (@coderef/core)\n**Responsibilities:**\n- Perform actual code analysis (AST parsing, dependency graph, etc.)\n- Execute commands (scan, query, impact, etc.)\n- Return structured JSON output\n\n**Key Components:**\n- CLI commands (scan, query, impact, complexity, patterns, etc.)\n- AST parser (TypeScript analysis)\n- Dependency graph engine\n\n**Dependencies:** `@coderef/core` (external TypeScript package)\n\n---\n\n#### Layer 4: Codebase Layer (User's Project)\n**Responsibilities:**\n- Provide source code for analysis\n- Maintain CodeRef2 index (`.coderef-index.json`)\n\n**Key Components:**\n- Source files (.ts, .tsx, .js, .jsx, etc.)\n- Test files\n- Dependencies (node_modules, package.json)\n\n---\n\n### Data Flow\n\n#### Example: Agent Calls coderef_scan\n\n```\n1. Agent Request (MCP Protocol)\n   \u2193\n   {\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/app\", \"use_ast\": true}}\n\n2. MCP Server (Python)\n   \u2193\n   - Validate: project_path exists, use_ast is boolean\n   - Route to: handle_coderef_scan(args)\n\n3. Tool Handler (Python)\n   \u2193\n   - Build command: [\"coderef\", \"scan\", \"/path/to/app\", \"--lang\", \"ts,tsx\", \"--json\", \"--ast\"]\n   - Execute: await asyncio.create_subprocess_exec(*cmd)\n   - Wait: timeout=120s\n\n4. CLI Subprocess (@coderef/core)\n   \u2193\n   - Parse: Scan /path/to/app for .ts/.tsx files\n   - Analyze: AST parsing to find functions, classes, components\n   - Output: JSON array to stdout\n\n5. Tool Handler (Python)\n   \u2193\n   - Parse: json.loads(stdout_text)\n   - Format: {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\n   - Return: [TextContent(type=\"text\", text=json_output)]\n\n6. MCP Server (Python)\n   \u2193\n   - Send response to stdout (MCP protocol)\n\n7. Agent Receives\n   \u2193\n   {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\n```\n\n---",
        "why:_design_decisions": "### Decision 1: Subprocess vs In-Process\n\n**Chosen:** Subprocess-based CLI wrapping\n**Why:**\n- @coderef/core is TypeScript (requires Node.js runtime)\n- Python MCP server is separate process (no Node.js bridge needed)\n- Isolation: One CLI crash doesn't crash MCP server\n- Single source of truth: CLI is canonical implementation\n\n**Alternative Rejected:** Port @coderef/core to Python\n**Why Rejected:** 6-month effort, maintenance burden, feature parity issues\n\n---\n\n### Decision 2: Async/Await Throughout\n\n**Chosen:** All handlers use `async def` + `asyncio.create_subprocess_exec`\n**Why:**\n- MCP protocol is async (JSON-RPC 2.0)\n- Subprocess I/O is inherently async\n- Allows concurrent tool calls (multiple agents)\n- Non-blocking event loop (server stays responsive)\n\n**Alternative Rejected:** Blocking `subprocess.run()` + threading\n**Why Rejected:** Threading adds complexity, async is more Pythonic\n\n---\n\n### Decision 3: Stateless Server\n\n**Chosen:** No caching, no persistent state\n**Why:**\n- Codebase changes frequently during development\n- Stale analysis could lead to wrong decisions\n- Agents need latest truth (not cached results)\n- Simpler to manage (no cache invalidation logic)\n\n**Alternative Rejected:** LRU cache with TTL\n**Why Rejected:** Added complexity, unclear invalidation strategy\n\n---\n\n### Decision 4: 120s Timeout Per Tool\n\n**Chosen:** Fixed 120s timeout for all tools\n**Why:**\n- Prevents infinite hangs (if CLI crashes or loops)\n- Reasonable for most projects (<100k LOC)\n- Long enough for AST scans (~15-20s for 50k LOC)\n- Short enough to fail fast for agents\n\n**Alternative Rejected:** Configurable timeout per tool\n**Why Rejected:** Over-engineering, 120s works for 95% of cases\n\n---\n\n### Decision 5: Handler-Based (Not Class-Based)\n\n**Chosen:** Each tool is a standalone async function\n**Why:**\n- Simple, functional approach\n- No shared state needed (stateless)\n- Easy to test in isolation\n- Clear input/output contract\n\n**Alternative Rejected:** Class-based handlers with inheritance\n**Why Rejected:** Unnecessary complexity, no code reuse benefit\n\n---",
        "when:_integration_points": "### Integration with coderef-workflow\n\n**Use Case:** Planning phase (section 0: PREPARATION)\n\n**Flow:**\n```\ncoderef-workflow (Python MCP Server)\n    \u251c\u2500 Calls: coderef_scan to discover existing code\n    \u251c\u2500 Calls: coderef_query to understand dependencies\n    \u251c\u2500 Calls: coderef_impact to assess refactoring risk\n    \u2514\u2500 Uses results to populate plan.json sections:\n        - 3_CURRENT_STATE_ANALYSIS\n        - 2_RISK_ASSESSMENT\n        - 6_IMPLEMENTATION_PHASES\n```\n\n**Communication:** Both servers use MCP protocol (can call each other via MCP client)\n\n---\n\n### Integration with coderef-personas\n\n**Use Case:** Agent execution (tasks)\n\n**Flow:**\n```\nAgent (Ava, Marcus, etc.)\n    \u251c\u2500 Activates via: /ava, /marcus (slash commands)\n    \u251c\u2500 During task execution:\n    \u2502   \u251c\u2500 Calls: coderef_query (\"What does this depend on?\")\n    \u2502   \u251c\u2500 Calls: coderef_impact (\"What breaks if I change this?\")\n    \u2502   \u2514\u2500 Calls: coderef_complexity (\"How complex is this?\")\n    \u2514\u2500 Makes informed decisions based on code intelligence\n```\n\n**Communication:** Personas call coderef-context tools via MCP protocol\n\n---\n\n### Integration with coderef-docs\n\n**Use Case:** Foundation doc generation\n\n**Flow:**\n```\ncoderef-docs (Python MCP Server)\n    \u251c\u2500 Calls: coderef_scan to extract API endpoints\n    \u251c\u2500 Calls: coderef_scan to extract schema entities\n    \u251c\u2500 Calls: coderef_scan to extract UI components\n    \u2514\u2500 Populates templates:\n        - API.md (with real endpoints)\n        - SCHEMA.md (with real data models)\n        - COMPONENTS.md (with real UI components)\n```\n\n**Communication:** Both servers use MCP protocol\n\n---\n\n### Integration with @coderef/core\n\n**Use Case:** All tool operations\n\n**Flow:**\n```\ncoderef-context MCP Server\n    \u251c\u2500 Detects CLI path via get_cli_command()\n    \u2502   \u251c\u2500 Check global: coderef --version\n    \u2502   \u251c\u2500 Check local: $CODEREF_CLI_PATH/dist/cli.js\n    \u2502   \u2514\u2500 Fallback: \"coderef\" command\n    \u2502\n    \u251c\u2500 Executes CLI commands via subprocess:\n    \u2502   \u251c\u2500 coderef scan <path> --json --ast\n    \u2502   \u251c\u2500 coderef query <target> --type <type> --json\n    \u2502   \u2514\u2500 ... (11 commands total)\n    \u2502\n    \u2514\u2500 Parses JSON output and returns to agent\n```\n\n**Communication:** Subprocess stdio (stdin/stdout)\n\n---",
        "technology_stack": "### Python Stack\n\n**Core:**\n- Python 3.11+ (async/await, type hints)\n- `mcp` - MCP protocol implementation\n- `asyncio` - Async subprocess execution\n- `json` - JSON parsing/serialization\n\n**Development:**\n- `pytest` - Unit testing\n- `mypy` - Type checking (future)\n- `black` - Code formatting (future)\n\n---\n\n### External Dependencies\n\n**@coderef/core:**\n- TypeScript/Node.js\n- AST parsing (ts-morph, babel-parser)\n- Dependency graph analysis\n- Pattern detection\n\n**Installation:**\n- Global: `npm install -g @coderef/core`\n- Local: `CODEREF_CLI_PATH=/path/to/cli`\n\n---\n\n### File System\n\n**Project Structure:**\n```\ncoderef-context/\n\u251c\u2500\u2500 server.py                    # MCP server (1073 lines)\n\u251c\u2500\u2500 pyproject.toml               # Python dependencies\n\u251c\u2500\u2500 README.md                    # User-facing docs\n\u251c\u2500\u2500 CLAUDE.md                    # AI context docs\n\u251c\u2500\u2500 coderef/\n\u2502   \u2514\u2500\u2500 foundation-docs/\n\u2502       \u251c\u2500\u2500 API.md               # API reference (generated)\n\u2502       \u251c\u2500\u2500 SCHEMA.md            # Schema reference (generated)\n\u2502       \u251c\u2500\u2500 COMPONENTS.md        # Component reference (generated)\n\u2502       \u2514\u2500\u2500 ARCHITECTURE.md      # This file\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_server.py           # Unit tests (future)\n```\n\n---",
        "deployment": "### Global Deployment (.mcp.json)\n\n```json\n{\n  \"mcpServers\": {\n    \"coderef-context\": {\n      \"command\": \"python\",\n      \"args\": [\"C:/Users/willh/.mcp-servers/coderef-context/server.py\"],\n      \"cwd\": \"C:/Users/willh/.mcp-servers/coderef-context\",\n      \"env\": {\n        \"CODEREF_CLI_PATH\": \"C:/Users/willh/Desktop/projects/coderef-system/packages/cli\"\n      },\n      \"description\": \"MCP server exposing @coderef/core CLI tools to Claude agents\",\n      \"tools\": [\n        \"coderef_scan\", \"coderef_query\", \"coderef_impact\",\n        \"coderef_complexity\", \"coderef_patterns\", \"coderef_coverage\",\n        \"coderef_context\", \"coderef_validate\", \"coderef_drift\",\n        \"coderef_diagram\", \"coderef_tag\"\n      ]\n    }\n  }\n}\n```\n\n**Location:** `~/.mcp.json` (global configuration)\n**Effect:** All Claude Code sessions have access to coderef-context tools\n\n---\n\n### Environment Configuration\n\n**CODEREF_CLI_PATH:**\n- Purpose: Override default CLI path\n- Default: `C:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli`\n- Usage: Set in `.mcp.json` env section\n\n**CLI Detection Logic:**\n1. Global install: `where coderef` (Windows) or `which coderef` (Unix)\n2. Test global: `coderef --version`\n3. Local path: `$CODEREF_CLI_PATH/dist/cli.js`\n4. Fallback: Try `coderef` command (may fail if not installed)\n\n---",
        "performance_characteristics": "### Latency\n\n**Tool Response Times (typical):**\n- `coderef_scan`: 5-15s (50k LOC, AST mode)\n- `coderef_query`: 1-3s (dependency lookup)\n- `coderef_impact`: 2-5s (impact analysis)\n- `coderef_complexity`: 10-30s (full context generation)\n- `coderef_patterns`: 10-30s (full context generation)\n- `coderef_context`: 10-30s (full project context)\n- Other tools: <5s\n\n**Bottlenecks:**\n- AST parsing (CPU-intensive, ~10-15s for 50k LOC)\n- File I/O (disk speed matters for large projects)\n- Subprocess overhead (~100-200ms per call)\n\n---\n\n### Scalability\n\n**Concurrent Requests:**\n- \u2705 Supported (async subprocess allows parallel execution)\n- Each tool call spawns independent subprocess\n- No shared state = no locking needed\n\n**Large Projects:**\n- \u2705 100k LOC: Scans complete in ~30-40s (within 120s timeout)\n- \u274c 500k LOC: May exceed 120s timeout (use smaller scope or increase timeout)\n\n**Memory:**\n- Python server: ~50-100 MB RAM\n- CLI subprocess: ~200-500 MB RAM per call (depends on project size)\n\n---\n\n### Caching Strategy\n\n**Current:** No caching (intentional)\n**Reason:** Accuracy over speed (code changes frequently)\n\n**Future (v2.0):**\n- Optional LRU cache with TTL (configurable)\n- Cache key: `(project_path, tool, args)`\n- Invalidation: Manual (agent calls cache_clear) or TTL expiry\n\n---",
        "error_handling_&_resilience": "### Error Categories\n\n**1. Timeout Errors**\n- Cause: CLI command exceeds 120s\n- Recovery: Kill subprocess, return timeout error\n- Agent Action: Retry with smaller scope or ask user\n\n**2. CLI Not Found Errors**\n- Cause: @coderef/core not installed or configured\n- Recovery: Return clear error message\n- Agent Action: Ask user to configure CODEREF_CLI_PATH\n\n**3. JSON Parse Errors**\n- Cause: CLI output malformed or contains progress messages\n- Recovery: Skip to JSON start (`[` or `{`), retry parse\n- Agent Action: Retry once, escalate if fails again\n\n**4. Subprocess Errors**\n- Cause: CLI crashes, OOM, permission denied\n- Recovery: Capture stderr, return error message\n- Agent Action: Check CLI works standalone, report to user\n\n---\n\n### Resilience Patterns\n\n**1. Graceful Degradation**\n- If CLI not found, return clear error (don't crash server)\n- If timeout, kill subprocess cleanly (no zombie processes)\n\n**2. Error Propagation**\n- CLI errors propagate to agent (stderr \u2192 JSON error response)\n- Agent can diagnose issues from error messages\n\n**3. No Cascading Failures**\n- One tool failure doesn't affect other tools (stateless)\n- Subprocess isolation prevents server crashes\n\n---",
        "security_considerations": "### Trust Model\n\n**Assumption:** Local server, trusted environment\n- No authentication required\n- Agents run on same machine\n- User controls codebase access\n\n**Risks:**\n- Malicious codebase could exploit CLI (AST parsing vulnerabilities)\n- No sandboxing (CLI has full file system access)\n\n**Mitigations:**\n- CLI is read-only (doesn't modify code except tag command)\n- Subprocess isolation limits blast radius\n- Timeout prevents infinite loops\n\n---\n\n### Input Validation\n\n**Validated:**\n- `project_path` must be absolute path (prevent path traversal)\n- `query_type`, `operation`, `format` must be enum values\n- `max_depth` must be positive integer 1-10\n\n**Not Validated:**\n- File contents (CLI handles parsing)\n- Element names (CLI validates existence)\n\n---",
        "future_architecture": "### v2.0 Planned Changes\n\n**1. Streaming Support**\n- Stream large scan results (avoid 100k element JSON)\n- Use MCP streaming protocol (future spec)\n\n**2. Optional Caching**\n- LRU cache with TTL (configurable)\n- Cache invalidation via agent call\n\n**3. Parallel Analysis**\n- Scan multiple directories in parallel\n- Reduce latency for multi-module projects\n\n**4. Performance Metrics**\n- Track latency per tool\n- Expose `/metrics` endpoint for monitoring\n\n**5. Health Checks**\n- `/health` endpoint for uptime monitoring\n- CLI version compatibility checks\n\n---",
        "references": "- **[API.md](API.md)** - API endpoint documentation\n- **[SCHEMA.md](SCHEMA.md)** - Data schema definitions\n- **[COMPONENTS.md](COMPONENTS.md)** - Component reference (handlers, patterns)\n- **[CLAUDE.md](../CLAUDE.md)** - AI context documentation\n- **[server.py](../server.py)** - Full implementation source code\n- **[@coderef/core](https://github.com/coderef-system)** - Upstream TypeScript analysis engine\n\n---",
        "ai_agent_instructions": "**When using this architecture:**\n1. Understand data flow: Agent \u2192 MCP Server \u2192 CLI Subprocess \u2192 Codebase\n2. Respect 120s timeout (large projects may need smaller scope)\n3. Handle errors gracefully (retry on timeout, ask user on CLI not found)\n4. Leverage stateless design (concurrent tool calls are safe)\n\n**When debugging:**\n1. Check CLI path detection logic first (`get_cli_command()`)\n2. Verify CLI works standalone (`coderef scan /path --json`)\n3. Check subprocess command construction (print `cmd` variable)\n4. Validate JSON parsing (CLI may output progress before JSON)\n\n**When extending:**\n1. Follow handler pattern (async, timeout, JSON parse, error handling)\n2. Add tool to both `list_tools()` and `call_tool()` router\n3. Test with real @coderef/core CLI before committing\n4. Update API.md, SCHEMA.md, COMPONENTS.md documentation\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This architecture reference helps you understand the system design, integration points, and how to extend the server with new capabilities."
      },
      "full_content": "# Architecture Documentation\n\n**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---\n\n## Purpose\n\nThis document describes the system architecture of the coderef-context MCP server. It explains the design decisions, module boundaries, data flow, technology stack, and integration points with the broader CodeRef ecosystem.\n\n---\n\n## Overview\n\nThe coderef-context server is a **Python-based MCP (Model Context Protocol) server** that exposes code intelligence tools from the @coderef/core CLI to AI agents. It acts as a bridge between:\n- **AI Agents** (Claude, GPT, etc.) via MCP protocol\n- **@coderef/core** (TypeScript analysis engine) via Node.js subprocess\n\n**Architecture Style:** Microservice (single-purpose server in multi-server ecosystem)\n**Communication:** Async I/O (stdio-based MCP protocol + subprocess)\n**State Management:** Stateless (no persistent storage)\n\n---\n\n## What: System Topology\n\n### High-Level Architecture\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         AI Agent (Claude)                        \u2502\n\u2502                     (Persona: Ava, Marcus, etc.)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502 MCP Protocol (JSON-RPC 2.0)\n                             \u2502 Transport: stdio (stdin/stdout)\n                             \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   coderef-context MCP Server                     \u2502\n\u2502                        (Python, asyncio)                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  MCP Server Core (server.py)                             \u2502   \u2502\n\u2502  \u2502  - Tool registration (@app.list_tools)                   \u2502   \u2502\n\u2502  \u2502  - Tool routing (@app.call_tool)                         \u2502   \u2502\n\u2502  \u2502  - Error handling & validation                           \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                             \u2502                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Tool Handlers (11 async functions)                       \u2502  \u2502\n\u2502  \u2502  - handle_coderef_scan                                    \u2502  \u2502\n\u2502  \u2502  - handle_coderef_query                                   \u2502  \u2502\n\u2502  \u2502  - handle_coderef_impact                                  \u2502  \u2502\n\u2502  \u2502  - ... (8 more handlers)                                  \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502 Subprocess (asyncio)\n                              \u2502 Commands: CLI_COMMAND + args\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    @coderef/core CLI                             \u2502\n\u2502                   (TypeScript/Node.js)                           \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  CLI Commands (via dist/cli.js)                          \u2502   \u2502\n\u2502  \u2502  - scan, query, impact, complexity                       \u2502   \u2502\n\u2502  \u2502  - patterns, coverage, context                           \u2502   \u2502\n\u2502  \u2502  - validate, drift, diagram, tag                         \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502 File I/O + AST parsing\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Project Codebase                          \u2502\n\u2502           (TypeScript, JavaScript, React, etc.)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\n---\n\n### Module Boundaries\n\n#### Layer 1: MCP Protocol Layer (server.py)\n**Responsibilities:**\n- Accept MCP tool calls via stdin (JSON-RPC 2.0)\n- Validate input schemas\n- Route to appropriate tool handler\n- Return responses via stdout\n\n**Key Components:**\n- `@app.list_tools()` - Tool registration\n- `@app.call_tool()` - Tool routing\n- `get_cli_command()` - CLI path detection\n\n**Dependencies:** `mcp`, `mcp.server.stdio`\n\n---\n\n#### Layer 2: Tool Handler Layer (server.py:434-1054)\n**Responsibilities:**\n- Parse tool arguments\n- Build CLI commands\n- Execute async subprocess\n- Parse JSON responses\n- Handle errors (timeout, CLI failure, JSON parse)\n\n**Key Components:**\n- 11 async handler functions (handle_coderef_scan, etc.)\n- Shared patterns: async subprocess, timeout, JSON parse\n\n**Dependencies:** `asyncio`, `subprocess`, `json`\n\n---\n\n#### Layer 3: CLI Subprocess Layer (@coderef/core)\n**Responsibilities:**\n- Perform actual code analysis (AST parsing, dependency graph, etc.)\n- Execute commands (scan, query, impact, etc.)\n- Return structured JSON output\n\n**Key Components:**\n- CLI commands (scan, query, impact, complexity, patterns, etc.)\n- AST parser (TypeScript analysis)\n- Dependency graph engine\n\n**Dependencies:** `@coderef/core` (external TypeScript package)\n\n---\n\n#### Layer 4: Codebase Layer (User's Project)\n**Responsibilities:**\n- Provide source code for analysis\n- Maintain CodeRef2 index (`.coderef-index.json`)\n\n**Key Components:**\n- Source files (.ts, .tsx, .js, .jsx, etc.)\n- Test files\n- Dependencies (node_modules, package.json)\n\n---\n\n### Data Flow\n\n#### Example: Agent Calls coderef_scan\n\n```\n1. Agent Request (MCP Protocol)\n   \u2193\n   {\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/app\", \"use_ast\": true}}\n\n2. MCP Server (Python)\n   \u2193\n   - Validate: project_path exists, use_ast is boolean\n   - Route to: handle_coderef_scan(args)\n\n3. Tool Handler (Python)\n   \u2193\n   - Build command: [\"coderef\", \"scan\", \"/path/to/app\", \"--lang\", \"ts,tsx\", \"--json\", \"--ast\"]\n   - Execute: await asyncio.create_subprocess_exec(*cmd)\n   - Wait: timeout=120s\n\n4. CLI Subprocess (@coderef/core)\n   \u2193\n   - Parse: Scan /path/to/app for .ts/.tsx files\n   - Analyze: AST parsing to find functions, classes, components\n   - Output: JSON array to stdout\n\n5. Tool Handler (Python)\n   \u2193\n   - Parse: json.loads(stdout_text)\n   - Format: {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\n   - Return: [TextContent(type=\"text\", text=json_output)]\n\n6. MCP Server (Python)\n   \u2193\n   - Send response to stdout (MCP protocol)\n\n7. Agent Receives\n   \u2193\n   {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\n```\n\n---\n\n## Why: Design Decisions\n\n### Decision 1: Subprocess vs In-Process\n\n**Chosen:** Subprocess-based CLI wrapping\n**Why:**\n- @coderef/core is TypeScript (requires Node.js runtime)\n- Python MCP server is separate process (no Node.js bridge needed)\n- Isolation: One CLI crash doesn't crash MCP server\n- Single source of truth: CLI is canonical implementation\n\n**Alternative Rejected:** Port @coderef/core to Python\n**Why Rejected:** 6-month effort, maintenance burden, feature parity issues\n\n---\n\n### Decision 2: Async/Await Throughout\n\n**Chosen:** All handlers use `async def` + `asyncio.create_subprocess_exec`\n**Why:**\n- MCP protocol is async (JSON-RPC 2.0)\n- Subprocess I/O is inherently async\n- Allows concurrent tool calls (multiple agents)\n- Non-blocking event loop (server stays responsive)\n\n**Alternative Rejected:** Blocking `subprocess.run()` + threading\n**Why Rejected:** Threading adds complexity, async is more Pythonic\n\n---\n\n### Decision 3: Stateless Server\n\n**Chosen:** No caching, no persistent state\n**Why:**\n- Codebase changes frequently during development\n- Stale analysis could lead to wrong decisions\n- Agents need latest truth (not cached results)\n- Simpler to manage (no cache invalidation logic)\n\n**Alternative Rejected:** LRU cache with TTL\n**Why Rejected:** Added complexity, unclear invalidation strategy\n\n---\n\n### Decision 4: 120s Timeout Per Tool\n\n**Chosen:** Fixed 120s timeout for all tools\n**Why:**\n- Prevents infinite hangs (if CLI crashes or loops)\n- Reasonable for most projects (<100k LOC)\n- Long enough for AST scans (~15-20s for 50k LOC)\n- Short enough to fail fast for agents\n\n**Alternative Rejected:** Configurable timeout per tool\n**Why Rejected:** Over-engineering, 120s works for 95% of cases\n\n---\n\n### Decision 5: Handler-Based (Not Class-Based)\n\n**Chosen:** Each tool is a standalone async function\n**Why:**\n- Simple, functional approach\n- No shared state needed (stateless)\n- Easy to test in isolation\n- Clear input/output contract\n\n**Alternative Rejected:** Class-based handlers with inheritance\n**Why Rejected:** Unnecessary complexity, no code reuse benefit\n\n---\n\n## When: Integration Points\n\n### Integration with coderef-workflow\n\n**Use Case:** Planning phase (section 0: PREPARATION)\n\n**Flow:**\n```\ncoderef-workflow (Python MCP Server)\n    \u251c\u2500 Calls: coderef_scan to discover existing code\n    \u251c\u2500 Calls: coderef_query to understand dependencies\n    \u251c\u2500 Calls: coderef_impact to assess refactoring risk\n    \u2514\u2500 Uses results to populate plan.json sections:\n        - 3_CURRENT_STATE_ANALYSIS\n        - 2_RISK_ASSESSMENT\n        - 6_IMPLEMENTATION_PHASES\n```\n\n**Communication:** Both servers use MCP protocol (can call each other via MCP client)\n\n---\n\n### Integration with coderef-personas\n\n**Use Case:** Agent execution (tasks)\n\n**Flow:**\n```\nAgent (Ava, Marcus, etc.)\n    \u251c\u2500 Activates via: /ava, /marcus (slash commands)\n    \u251c\u2500 During task execution:\n    \u2502   \u251c\u2500 Calls: coderef_query (\"What does this depend on?\")\n    \u2502   \u251c\u2500 Calls: coderef_impact (\"What breaks if I change this?\")\n    \u2502   \u2514\u2500 Calls: coderef_complexity (\"How complex is this?\")\n    \u2514\u2500 Makes informed decisions based on code intelligence\n```\n\n**Communication:** Personas call coderef-context tools via MCP protocol\n\n---\n\n### Integration with coderef-docs\n\n**Use Case:** Foundation doc generation\n\n**Flow:**\n```\ncoderef-docs (Python MCP Server)\n    \u251c\u2500 Calls: coderef_scan to extract API endpoints\n    \u251c\u2500 Calls: coderef_scan to extract schema entities\n    \u251c\u2500 Calls: coderef_scan to extract UI components\n    \u2514\u2500 Populates templates:\n        - API.md (with real endpoints)\n        - SCHEMA.md (with real data models)\n        - COMPONENTS.md (with real UI components)\n```\n\n**Communication:** Both servers use MCP protocol\n\n---\n\n### Integration with @coderef/core\n\n**Use Case:** All tool operations\n\n**Flow:**\n```\ncoderef-context MCP Server\n    \u251c\u2500 Detects CLI path via get_cli_command()\n    \u2502   \u251c\u2500 Check global: coderef --version\n    \u2502   \u251c\u2500 Check local: $CODEREF_CLI_PATH/dist/cli.js\n    \u2502   \u2514\u2500 Fallback: \"coderef\" command\n    \u2502\n    \u251c\u2500 Executes CLI commands via subprocess:\n    \u2502   \u251c\u2500 coderef scan <path> --json --ast\n    \u2502   \u251c\u2500 coderef query <target> --type <type> --json\n    \u2502   \u2514\u2500 ... (11 commands total)\n    \u2502\n    \u2514\u2500 Parses JSON output and returns to agent\n```\n\n**Communication:** Subprocess stdio (stdin/stdout)\n\n---\n\n## Technology Stack\n\n### Python Stack\n\n**Core:**\n- Python 3.11+ (async/await, type hints)\n- `mcp` - MCP protocol implementation\n- `asyncio` - Async subprocess execution\n- `json` - JSON parsing/serialization\n\n**Development:**\n- `pytest` - Unit testing\n- `mypy` - Type checking (future)\n- `black` - Code formatting (future)\n\n---\n\n### External Dependencies\n\n**@coderef/core:**\n- TypeScript/Node.js\n- AST parsing (ts-morph, babel-parser)\n- Dependency graph analysis\n- Pattern detection\n\n**Installation:**\n- Global: `npm install -g @coderef/core`\n- Local: `CODEREF_CLI_PATH=/path/to/cli`\n\n---\n\n### File System\n\n**Project Structure:**\n```\ncoderef-context/\n\u251c\u2500\u2500 server.py                    # MCP server (1073 lines)\n\u251c\u2500\u2500 pyproject.toml               # Python dependencies\n\u251c\u2500\u2500 README.md                    # User-facing docs\n\u251c\u2500\u2500 CLAUDE.md                    # AI context docs\n\u251c\u2500\u2500 coderef/\n\u2502   \u2514\u2500\u2500 foundation-docs/\n\u2502       \u251c\u2500\u2500 API.md               # API reference (generated)\n\u2502       \u251c\u2500\u2500 SCHEMA.md            # Schema reference (generated)\n\u2502       \u251c\u2500\u2500 COMPONENTS.md        # Component reference (generated)\n\u2502       \u2514\u2500\u2500 ARCHITECTURE.md      # This file\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_server.py           # Unit tests (future)\n```\n\n---\n\n## Deployment\n\n### Global Deployment (.mcp.json)\n\n```json\n{\n  \"mcpServers\": {\n    \"coderef-context\": {\n      \"command\": \"python\",\n      \"args\": [\"C:/Users/willh/.mcp-servers/coderef-context/server.py\"],\n      \"cwd\": \"C:/Users/willh/.mcp-servers/coderef-context\",\n      \"env\": {\n        \"CODEREF_CLI_PATH\": \"C:/Users/willh/Desktop/projects/coderef-system/packages/cli\"\n      },\n      \"description\": \"MCP server exposing @coderef/core CLI tools to Claude agents\",\n      \"tools\": [\n        \"coderef_scan\", \"coderef_query\", \"coderef_impact\",\n        \"coderef_complexity\", \"coderef_patterns\", \"coderef_coverage\",\n        \"coderef_context\", \"coderef_validate\", \"coderef_drift\",\n        \"coderef_diagram\", \"coderef_tag\"\n      ]\n    }\n  }\n}\n```\n\n**Location:** `~/.mcp.json` (global configuration)\n**Effect:** All Claude Code sessions have access to coderef-context tools\n\n---\n\n### Environment Configuration\n\n**CODEREF_CLI_PATH:**\n- Purpose: Override default CLI path\n- Default: `C:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli`\n- Usage: Set in `.mcp.json` env section\n\n**CLI Detection Logic:**\n1. Global install: `where coderef` (Windows) or `which coderef` (Unix)\n2. Test global: `coderef --version`\n3. Local path: `$CODEREF_CLI_PATH/dist/cli.js`\n4. Fallback: Try `coderef` command (may fail if not installed)\n\n---\n\n## Performance Characteristics\n\n### Latency\n\n**Tool Response Times (typical):**\n- `coderef_scan`: 5-15s (50k LOC, AST mode)\n- `coderef_query`: 1-3s (dependency lookup)\n- `coderef_impact`: 2-5s (impact analysis)\n- `coderef_complexity`: 10-30s (full context generation)\n- `coderef_patterns`: 10-30s (full context generation)\n- `coderef_context`: 10-30s (full project context)\n- Other tools: <5s\n\n**Bottlenecks:**\n- AST parsing (CPU-intensive, ~10-15s for 50k LOC)\n- File I/O (disk speed matters for large projects)\n- Subprocess overhead (~100-200ms per call)\n\n---\n\n### Scalability\n\n**Concurrent Requests:**\n- \u2705 Supported (async subprocess allows parallel execution)\n- Each tool call spawns independent subprocess\n- No shared state = no locking needed\n\n**Large Projects:**\n- \u2705 100k LOC: Scans complete in ~30-40s (within 120s timeout)\n- \u274c 500k LOC: May exceed 120s timeout (use smaller scope or increase timeout)\n\n**Memory:**\n- Python server: ~50-100 MB RAM\n- CLI subprocess: ~200-500 MB RAM per call (depends on project size)\n\n---\n\n### Caching Strategy\n\n**Current:** No caching (intentional)\n**Reason:** Accuracy over speed (code changes frequently)\n\n**Future (v2.0):**\n- Optional LRU cache with TTL (configurable)\n- Cache key: `(project_path, tool, args)`\n- Invalidation: Manual (agent calls cache_clear) or TTL expiry\n\n---\n\n## Error Handling & Resilience\n\n### Error Categories\n\n**1. Timeout Errors**\n- Cause: CLI command exceeds 120s\n- Recovery: Kill subprocess, return timeout error\n- Agent Action: Retry with smaller scope or ask user\n\n**2. CLI Not Found Errors**\n- Cause: @coderef/core not installed or configured\n- Recovery: Return clear error message\n- Agent Action: Ask user to configure CODEREF_CLI_PATH\n\n**3. JSON Parse Errors**\n- Cause: CLI output malformed or contains progress messages\n- Recovery: Skip to JSON start (`[` or `{`), retry parse\n- Agent Action: Retry once, escalate if fails again\n\n**4. Subprocess Errors**\n- Cause: CLI crashes, OOM, permission denied\n- Recovery: Capture stderr, return error message\n- Agent Action: Check CLI works standalone, report to user\n\n---\n\n### Resilience Patterns\n\n**1. Graceful Degradation**\n- If CLI not found, return clear error (don't crash server)\n- If timeout, kill subprocess cleanly (no zombie processes)\n\n**2. Error Propagation**\n- CLI errors propagate to agent (stderr \u2192 JSON error response)\n- Agent can diagnose issues from error messages\n\n**3. No Cascading Failures**\n- One tool failure doesn't affect other tools (stateless)\n- Subprocess isolation prevents server crashes\n\n---\n\n## Security Considerations\n\n### Trust Model\n\n**Assumption:** Local server, trusted environment\n- No authentication required\n- Agents run on same machine\n- User controls codebase access\n\n**Risks:**\n- Malicious codebase could exploit CLI (AST parsing vulnerabilities)\n- No sandboxing (CLI has full file system access)\n\n**Mitigations:**\n- CLI is read-only (doesn't modify code except tag command)\n- Subprocess isolation limits blast radius\n- Timeout prevents infinite loops\n\n---\n\n### Input Validation\n\n**Validated:**\n- `project_path` must be absolute path (prevent path traversal)\n- `query_type`, `operation`, `format` must be enum values\n- `max_depth` must be positive integer 1-10\n\n**Not Validated:**\n- File contents (CLI handles parsing)\n- Element names (CLI validates existence)\n\n---\n\n## Future Architecture\n\n### v2.0 Planned Changes\n\n**1. Streaming Support**\n- Stream large scan results (avoid 100k element JSON)\n- Use MCP streaming protocol (future spec)\n\n**2. Optional Caching**\n- LRU cache with TTL (configurable)\n- Cache invalidation via agent call\n\n**3. Parallel Analysis**\n- Scan multiple directories in parallel\n- Reduce latency for multi-module projects\n\n**4. Performance Metrics**\n- Track latency per tool\n- Expose `/metrics` endpoint for monitoring\n\n**5. Health Checks**\n- `/health` endpoint for uptime monitoring\n- CLI version compatibility checks\n\n---\n\n## References\n\n- **[API.md](API.md)** - API endpoint documentation\n- **[SCHEMA.md](SCHEMA.md)** - Data schema definitions\n- **[COMPONENTS.md](COMPONENTS.md)** - Component reference (handlers, patterns)\n- **[CLAUDE.md](../CLAUDE.md)** - AI context documentation\n- **[server.py](../server.py)** - Full implementation source code\n- **[@coderef/core](https://github.com/coderef-system)** - Upstream TypeScript analysis engine\n\n---\n\n## AI Agent Instructions\n\n**When using this architecture:**\n1. Understand data flow: Agent \u2192 MCP Server \u2192 CLI Subprocess \u2192 Codebase\n2. Respect 120s timeout (large projects may need smaller scope)\n3. Handle errors gracefully (retry on timeout, ask user on CLI not found)\n4. Leverage stateless design (concurrent tool calls are safe)\n\n**When debugging:**\n1. Check CLI path detection logic first (`get_cli_command()`)\n2. Verify CLI works standalone (`coderef scan /path --json`)\n3. Check subprocess command construction (print `cmd` variable)\n4. Validate JSON parsing (CLI may output progress before JSON)\n\n**When extending:**\n1. Follow handler pattern (async, timeout, JSON parse, error handling)\n2. Add tool to both `list_tools()` and `call_tool()` router\n3. Test with real @coderef/core CLI before committing\n4. Update API.md, SCHEMA.md, COMPONENTS.md documentation\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This architecture reference helps you understand the system design, integration points, and how to extend the server with new capabilities.\n",
      "word_count": 2276
    },
    "schema": {
      "sections": {
        "schema_documentation": "**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Schema Version:** 1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---",
        "purpose": "This document defines the data schemas and type definitions used by the coderef-context MCP server. It describes the structure of tool inputs, outputs, CLI responses, and internal data models used for code intelligence operations.\n\n---",
        "overview": "The coderef-context server operates on structured JSON data exchanged between:\n1. **MCP Client** (AI Agent) \u2194 MCP Server (Python)\n2. **MCP Server** (Python) \u2194 CLI Subprocess (@coderef/core)\n\nAll data follows strict JSON Schema validation. No database is used\u2014data flows entirely through in-memory JSON structures and subprocess stdio.\n\n---",
        "what:_schema_definitions": "### 1. Tool Input Schemas\n\nAll MCP tools accept structured JSON inputs validated against these schemas:\n\n#### ScanInput\n```typescript\ninterface ScanInput {\n  project_path: string;           // Absolute path to project root\n  languages?: string[];           // Default: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n  use_ast?: boolean;              // Default: true (99% accuracy vs regex)\n}\n```\n\n**Validation Rules:**\n- `project_path` must be absolute path\n- `languages` must be valid file extensions\n- `use_ast` must be boolean\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/frontend-app\",\n  \"languages\": [\"ts\", \"tsx\"],\n  \"use_ast\": true\n}\n```\n\n---\n\n#### QueryInput\n```typescript\ninterface QueryInput {\n  project_path: string;\n  query_type: \"calls\" | \"calls-me\" | \"imports\" | \"imports-me\" | \"depends-on\" | \"depends-on-me\";\n  target: string;                 // e.g., 'authenticateUser' or 'AuthService#login'\n  source?: string;                // For path queries\n  max_depth?: number;             // Default: 3\n}\n```\n\n**Validation Rules:**\n- `query_type` must be one of 6 enum values\n- `target` is required, must be non-empty string\n- `max_depth` must be positive integer 1-10\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"max_depth\": 3\n}\n```\n\n---\n\n#### ImpactInput\n```typescript\ninterface ImpactInput {\n  project_path: string;\n  element: string;                // Element to analyze (e.g., 'AuthService')\n  operation?: \"modify\" | \"delete\" | \"refactor\";  // Default: \"modify\"\n  max_depth?: number;             // Default: 3\n}\n```\n\n**Validation Rules:**\n- `element` must be valid code element name\n- `operation` must be one of 3 enum values\n- `max_depth` must be positive integer 1-10\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"max_depth\": 3\n}\n```\n\n---\n\n#### ComplexityInput\n```typescript\ninterface ComplexityInput {\n  project_path: string;\n  element: string;                // Element to analyze\n}\n```\n\n**Validation Rules:**\n- `element` must be non-empty string\n\n---\n\n#### PatternsInput\n```typescript\ninterface PatternsInput {\n  project_path: string;\n  pattern_type?: string;          // Type of pattern to find (optional)\n  limit?: number;                 // Default: 10\n}\n```\n\n**Validation Rules:**\n- `limit` must be positive integer 1-100\n\n---\n\n#### CoverageInput\n```typescript\ninterface CoverageInput {\n  project_path: string;\n  format?: \"summary\" | \"detailed\";  // Default: \"summary\"\n}\n```\n\n---\n\n#### ContextInput\n```typescript\ninterface ContextInput {\n  project_path: string;\n  languages?: string[];           // Default: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n  output_format?: \"json\" | \"markdown\" | \"both\";  // Default: \"json\"\n}\n```\n\n---\n\n#### ValidateInput\n```typescript\ninterface ValidateInput {\n  project_path: string;\n  pattern?: string;               // File glob pattern, default: \"**/*.ts\"\n}\n```\n\n---\n\n#### DriftInput\n```typescript\ninterface DriftInput {\n  project_path: string;\n  index_path?: string;            // Default: \".coderef-index.json\"\n}\n```\n\n---\n\n#### DiagramInput\n```typescript\ninterface DiagramInput {\n  project_path: string;\n  diagram_type?: \"dependencies\" | \"calls\" | \"imports\" | \"all\";  // Default: \"dependencies\"\n  format?: \"mermaid\" | \"dot\";     // Default: \"mermaid\"\n  depth?: number;                 // Default: 2\n}\n```\n\n---\n\n#### TagInput\n```typescript\ninterface TagInput {\n  path: string;                   // File or directory path to tag\n  dry_run?: boolean;              // Default: false\n  force?: boolean;                // Default: false\n  verbose?: boolean;              // Default: false\n  update_lineno?: boolean;        // Default: false\n  include_private?: boolean;      // Default: false\n  lang?: string;                  // Default: \"ts,tsx,js,jsx\" (comma-separated)\n  exclude?: string;               // Comma-separated exclusion patterns\n}\n```\n\n**Validation Rules:**\n- `path` is required, must be valid file or directory path\n- All flags are optional booleans\n\n---\n\n### 2. Tool Output Schemas\n\nAll MCP tools return structured JSON responses:\n\n#### ScanOutput\n```typescript\ninterface ScanOutput {\n  success: boolean;\n  elements_found: number;\n  elements: CodeElement[];\n}\n\ninterface CodeElement {\n  name: string;                   // Element name (e.g., \"ThemeProvider\")\n  type: \"function\" | \"class\" | \"component\" | \"hook\" | \"interface\" | \"type\";\n  file: string;                   // Relative file path\n  line: number;                   // Line number where defined\n  metadata?: Record<string, any>; // Additional metadata\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\n      \"name\": \"ThemeProvider\",\n      \"type\": \"component\",\n      \"file\": \"src/theme/ThemeProvider.tsx\",\n      \"line\": 10\n    }\n  ]\n}\n```\n\n---\n\n#### QueryOutput\n```typescript\ninterface QueryOutput {\n  success: boolean;\n  query_type: string;\n  target: string;\n  results: Relationship[];\n}\n\ninterface Relationship {\n  from: string;                   // Source element\n  to: string;                     // Target element\n  type: \"import\" | \"call\" | \"dependency\";\n  file: string;                   // Where relationship exists\n  line?: number;                  // Line number (optional)\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"query_type\": \"imports\",\n  \"target\": \"CheckoutComponent\",\n  \"results\": [\n    {\n      \"from\": \"CheckoutComponent\",\n      \"to\": \"PaymentGateway\",\n      \"type\": \"import\",\n      \"file\": \"src/checkout/Checkout.tsx\",\n      \"line\": 5\n    }\n  ]\n}\n```\n\n---\n\n#### ImpactOutput\n```typescript\ninterface ImpactOutput {\n  success: boolean;\n  element: string;\n  operation: \"modify\" | \"delete\" | \"refactor\";\n  impact: ImpactAnalysis;\n}\n\ninterface ImpactAnalysis {\n  affected_files: number;\n  risk_level: \"LOW\" | \"MEDIUM\" | \"HIGH\" | \"CRITICAL\";\n  ripple_effects: RippleEffect[];\n}\n\ninterface RippleEffect {\n  file: string;                   // Affected file path\n  impact: string;                 // Description (e.g., \"direct call\", \"indirect dependency\")\n  severity?: \"minor\" | \"major\" | \"breaking\";\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\",\n        \"severity\": \"major\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n#### ComplexityOutput\n```typescript\ninterface ComplexityOutput {\n  success: boolean;\n  element: string;\n  note: string;\n  context: ComplexityMetrics;\n}\n\ninterface ComplexityMetrics {\n  lines_of_code: number;\n  cyclomatic_complexity: number;  // Measure of code paths\n  dependencies: number;           // Count of imports/dependencies\n  test_coverage: number;          // Decimal 0.0-1.0 (e.g., 0.65 = 65%)\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"element\": \"ReportGenerator\",\n  \"note\": \"Complexity metrics derived from context generation\",\n  \"context\": {\n    \"lines_of_code\": 245,\n    \"cyclomatic_complexity\": 8,\n    \"dependencies\": 6,\n    \"test_coverage\": 0.65\n  }\n}\n```\n\n---\n\n#### PatternsOutput\n```typescript\ninterface PatternsOutput {\n  success: boolean;\n  pattern_type: string;\n  limit: number;\n  patterns: Record<string, PatternInfo>;\n}\n\ninterface PatternInfo {\n  files: string[];                // Files where pattern appears\n  usage: number;                  // Count of occurrences\n  description?: string;           // Pattern description\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"pattern_type\": \"data-fetching\",\n  \"limit\": 5,\n  \"patterns\": {\n    \"React Query pattern\": {\n      \"files\": [\"src/api/hooks.ts\"],\n      \"usage\": 23,\n      \"description\": \"Async data fetching with caching\"\n    }\n  }\n}\n```\n\n---\n\n#### CoverageOutput\n```typescript\ninterface CoverageOutput {\n  success: boolean;\n  coverage: CoverageReport;\n}\n\ninterface CoverageReport {\n  overall: number;                // Overall coverage % (0.0-1.0)\n  by_file: Record<string, number>; // Per-file coverage\n  untested_files?: string[];      // Files with 0% coverage\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"coverage\": {\n    \"overall\": 0.72,\n    \"by_file\": {\n      \"src/auth.ts\": 0.85,\n      \"src/checkout.ts\": 0.60\n    },\n    \"untested_files\": [\"src/legacy.ts\"]\n  }\n}\n```\n\n---\n\n#### ContextOutput\n```typescript\ninterface ContextOutput {\n  success: boolean;\n  format: \"json\" | \"markdown\" | \"both\";\n  context: ProjectContext;\n}\n\ninterface ProjectContext {\n  project_summary: string;\n  elements: CodeElement[];\n  dependencies: Record<string, string[]>;\n  test_patterns: Record<string, PatternInfo>;\n  architecture_notes?: string;\n}\n```\n\n---\n\n#### ValidateOutput\n```typescript\ninterface ValidateOutput {\n  success: boolean;\n  pattern: string;\n  validation: ValidationReport;\n}\n\ninterface ValidationReport {\n  valid_references: number;\n  invalid_references: number;\n  errors: ValidationError[];\n}\n\ninterface ValidationError {\n  file: string;\n  line: number;\n  reference: string;\n  error: string;\n}\n```\n\n---\n\n#### DriftOutput\n```typescript\ninterface DriftOutput {\n  success: boolean;\n  drift_report: DriftReport;\n}\n\ninterface DriftReport {\n  added_elements: number;\n  removed_elements: number;\n  modified_elements: number;\n  details?: DriftDetail[];\n}\n\ninterface DriftDetail {\n  element: string;\n  change_type: \"added\" | \"removed\" | \"modified\";\n  file: string;\n}\n```\n\n---\n\n#### DiagramOutput\n```typescript\n// For Mermaid/Dot formats, returns text directly\ntype DiagramOutput = string;\n\n// For JSON format, returns structured graph\ninterface DiagramOutputJSON {\n  success: boolean;\n  diagram: GraphData;\n}\n\ninterface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n\ninterface GraphNode {\n  id: string;\n  label: string;\n  type: \"function\" | \"class\" | \"component\" | \"module\";\n}\n\ninterface GraphEdge {\n  from: string;\n  to: string;\n  label?: string;\n}\n```\n\n---\n\n#### TagOutput\n```typescript\n// Returns plain text output (not JSON)\ntype TagOutput = string;\n\n// Example output:\n// \"Tagged 45 elements in 12 files:\n//  - 18 functions (@Fn)\n//  - 12 classes (@Cl)\n//  - 15 components (@Cp)\"\n```\n\n---\n\n### 3. Error Schemas\n\nAll tools return structured errors on failure:\n\n```typescript\ninterface ToolError {\n  error: string;                  // Human-readable error message\n  code?: string;                  // Error code (e.g., \"TIMEOUT\", \"CLI_NOT_FOUND\")\n  details?: any;                  // Additional context\n}\n```\n\n**Common Error Codes:**\n- `TIMEOUT` - Command exceeded 120s timeout\n- `CLI_NOT_FOUND` - @coderef/core CLI not installed or configured\n- `JSON_PARSE_ERROR` - CLI output malformed\n- `INVALID_INPUT` - Input validation failed\n- `ELEMENT_NOT_FOUND` - Target element doesn't exist\n- `SUBPROCESS_ERROR` - CLI subprocess crashed\n\n**Example:**\n```json\n{\n  \"error\": \"Error: Scan timeout (120s exceeded)\",\n  \"code\": \"TIMEOUT\",\n  \"details\": {\n    \"project_path\": \"/large/project\",\n    \"timeout\": 120\n  }\n}\n```\n\n---",
        "why:_schema_design_decisions": "### Decision 1: JSON-Only Communication\n**Why:** MCP protocol is JSON-based, @coderef/core CLI supports `--json` flag\n**Benefit:** Type-safe, structured, parseable by agents\n**Alternative Rejected:** Plain text output (harder to parse, error-prone)\n\n### Decision 2: Flat Input Schemas\n**Why:** Simple to validate, easy for agents to construct\n**Benefit:** Fewer nesting errors, clear parameter expectations\n**Alternative Rejected:** Nested object parameters (more complexity)\n\n### Decision 3: Success Boolean\n**Why:** Explicit success/failure distinction\n**Benefit:** Agents can check `success` before processing results\n**Alternative Rejected:** HTTP-style status codes (overkill for local server)\n\n### Decision 4: Enums for Fixed Values\n**Why:** Prevents typos, provides autocomplete hints\n**Benefit:** Compile-time validation, clear API contract\n**Alternative Rejected:** Arbitrary strings (error-prone)\n\n---",
        "when:_schema_evolution": "### Versioning Strategy\nSchema version follows semantic versioning (SemVer):\n- **Major:** Breaking changes (remove fields, change types)\n- **Minor:** Backward-compatible additions (new optional fields)\n- **Patch:** Documentation updates, clarifications\n\n### Current Version: 1.0\n- All 11 tools have stable input/output schemas\n- No breaking changes planned for v1.x series\n\n### Future Schema Changes (v2.0 candidates)\n- Add streaming support for large scan results\n- Add pagination for query results\n- Add optional caching layer with cache keys\n\n---",
        "examples": "### Example 1: Valid ScanInput\n```json\n{\n  \"project_path\": \"/Users/dev/frontend-app\",\n  \"languages\": [\"ts\", \"tsx\"],\n  \"use_ast\": true\n}\n```\n\n**Validation:** \u2705 Pass\n**Reason:** All required fields present, types correct, AST flag is boolean\n\n---\n\n### Example 2: Invalid QueryInput (Missing target)\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"query_type\": \"calls-me\"\n}\n```\n\n**Validation:** \u274c Fail\n**Error:** `target parameter is required`\n\n---\n\n### Example 3: Valid ImpactOutput\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\",\n        \"severity\": \"major\"\n      }\n    ]\n  }\n}\n```\n\n**Validation:** \u2705 Pass\n**Reason:** All required fields present, risk_level is valid enum\n\n---",
        "relationships_&_constraints": "### Schema Relationships\n\n```\nScanInput \u2192 ScanOutput \u2192 CodeElement[]\nQueryInput \u2192 QueryOutput \u2192 Relationship[]\nImpactInput \u2192 ImpactOutput \u2192 ImpactAnalysis \u2192 RippleEffect[]\n```\n\n### Cross-Schema Constraints\n\n1. **CodeElement.type** values must match query target types\n2. **QueryOutput.results** must reference valid **CodeElement** names from scan\n3. **ImpactOutput.impact.affected_files** count must match **RippleEffect[]** length\n4. **ComplexityMetrics.test_coverage** must be decimal 0.0-1.0\n\n---",
        "references": "- **[API.md](API.md)** - API endpoint documentation (uses these schemas)\n- **[ARCHITECTURE.md](ARCHITECTURE.md)** - System architecture (data flow through schemas)\n- **[server.py](../server.py)** - Schema validation implementation\n- **[@coderef/core CLI](https://github.com/coderef-system)** - Upstream schema definitions\n\n---",
        "ai_agent_instructions": "**When constructing tool inputs:**\n1. Validate required fields before calling tool (prevent validation errors)\n2. Use enums exactly as defined (avoid typos)\n3. Provide absolute paths for `project_path` (not relative)\n4. Set appropriate timeouts for large projects\n\n**When parsing tool outputs:**\n1. Check `success` field first before accessing results\n2. Handle errors gracefully (retry on TIMEOUT, ask user on CLI_NOT_FOUND)\n3. Validate output schema before using data (defensive parsing)\n4. Extract `CodeElement[]` from scan, then use names in query/impact calls\n\n**Schema validation tips:**\n- TypeScript interfaces above are for documentation\u2014Python server uses JSON Schema internally\n- Missing optional fields default to documented defaults\n- Extra fields are ignored (forward compatibility)\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This schema reference ensures type-safe tool usage. Validate inputs before calling tools to avoid errors."
      },
      "full_content": "# Schema Documentation\n\n**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Schema Version:** 1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---\n\n## Purpose\n\nThis document defines the data schemas and type definitions used by the coderef-context MCP server. It describes the structure of tool inputs, outputs, CLI responses, and internal data models used for code intelligence operations.\n\n---\n\n## Overview\n\nThe coderef-context server operates on structured JSON data exchanged between:\n1. **MCP Client** (AI Agent) \u2194 MCP Server (Python)\n2. **MCP Server** (Python) \u2194 CLI Subprocess (@coderef/core)\n\nAll data follows strict JSON Schema validation. No database is used\u2014data flows entirely through in-memory JSON structures and subprocess stdio.\n\n---\n\n## What: Schema Definitions\n\n### 1. Tool Input Schemas\n\nAll MCP tools accept structured JSON inputs validated against these schemas:\n\n#### ScanInput\n```typescript\ninterface ScanInput {\n  project_path: string;           // Absolute path to project root\n  languages?: string[];           // Default: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n  use_ast?: boolean;              // Default: true (99% accuracy vs regex)\n}\n```\n\n**Validation Rules:**\n- `project_path` must be absolute path\n- `languages` must be valid file extensions\n- `use_ast` must be boolean\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/frontend-app\",\n  \"languages\": [\"ts\", \"tsx\"],\n  \"use_ast\": true\n}\n```\n\n---\n\n#### QueryInput\n```typescript\ninterface QueryInput {\n  project_path: string;\n  query_type: \"calls\" | \"calls-me\" | \"imports\" | \"imports-me\" | \"depends-on\" | \"depends-on-me\";\n  target: string;                 // e.g., 'authenticateUser' or 'AuthService#login'\n  source?: string;                // For path queries\n  max_depth?: number;             // Default: 3\n}\n```\n\n**Validation Rules:**\n- `query_type` must be one of 6 enum values\n- `target` is required, must be non-empty string\n- `max_depth` must be positive integer 1-10\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"max_depth\": 3\n}\n```\n\n---\n\n#### ImpactInput\n```typescript\ninterface ImpactInput {\n  project_path: string;\n  element: string;                // Element to analyze (e.g., 'AuthService')\n  operation?: \"modify\" | \"delete\" | \"refactor\";  // Default: \"modify\"\n  max_depth?: number;             // Default: 3\n}\n```\n\n**Validation Rules:**\n- `element` must be valid code element name\n- `operation` must be one of 3 enum values\n- `max_depth` must be positive integer 1-10\n\n**Example:**\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"max_depth\": 3\n}\n```\n\n---\n\n#### ComplexityInput\n```typescript\ninterface ComplexityInput {\n  project_path: string;\n  element: string;                // Element to analyze\n}\n```\n\n**Validation Rules:**\n- `element` must be non-empty string\n\n---\n\n#### PatternsInput\n```typescript\ninterface PatternsInput {\n  project_path: string;\n  pattern_type?: string;          // Type of pattern to find (optional)\n  limit?: number;                 // Default: 10\n}\n```\n\n**Validation Rules:**\n- `limit` must be positive integer 1-100\n\n---\n\n#### CoverageInput\n```typescript\ninterface CoverageInput {\n  project_path: string;\n  format?: \"summary\" | \"detailed\";  // Default: \"summary\"\n}\n```\n\n---\n\n#### ContextInput\n```typescript\ninterface ContextInput {\n  project_path: string;\n  languages?: string[];           // Default: [\"ts\", \"tsx\", \"js\", \"jsx\"]\n  output_format?: \"json\" | \"markdown\" | \"both\";  // Default: \"json\"\n}\n```\n\n---\n\n#### ValidateInput\n```typescript\ninterface ValidateInput {\n  project_path: string;\n  pattern?: string;               // File glob pattern, default: \"**/*.ts\"\n}\n```\n\n---\n\n#### DriftInput\n```typescript\ninterface DriftInput {\n  project_path: string;\n  index_path?: string;            // Default: \".coderef-index.json\"\n}\n```\n\n---\n\n#### DiagramInput\n```typescript\ninterface DiagramInput {\n  project_path: string;\n  diagram_type?: \"dependencies\" | \"calls\" | \"imports\" | \"all\";  // Default: \"dependencies\"\n  format?: \"mermaid\" | \"dot\";     // Default: \"mermaid\"\n  depth?: number;                 // Default: 2\n}\n```\n\n---\n\n#### TagInput\n```typescript\ninterface TagInput {\n  path: string;                   // File or directory path to tag\n  dry_run?: boolean;              // Default: false\n  force?: boolean;                // Default: false\n  verbose?: boolean;              // Default: false\n  update_lineno?: boolean;        // Default: false\n  include_private?: boolean;      // Default: false\n  lang?: string;                  // Default: \"ts,tsx,js,jsx\" (comma-separated)\n  exclude?: string;               // Comma-separated exclusion patterns\n}\n```\n\n**Validation Rules:**\n- `path` is required, must be valid file or directory path\n- All flags are optional booleans\n\n---\n\n### 2. Tool Output Schemas\n\nAll MCP tools return structured JSON responses:\n\n#### ScanOutput\n```typescript\ninterface ScanOutput {\n  success: boolean;\n  elements_found: number;\n  elements: CodeElement[];\n}\n\ninterface CodeElement {\n  name: string;                   // Element name (e.g., \"ThemeProvider\")\n  type: \"function\" | \"class\" | \"component\" | \"hook\" | \"interface\" | \"type\";\n  file: string;                   // Relative file path\n  line: number;                   // Line number where defined\n  metadata?: Record<string, any>; // Additional metadata\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\n      \"name\": \"ThemeProvider\",\n      \"type\": \"component\",\n      \"file\": \"src/theme/ThemeProvider.tsx\",\n      \"line\": 10\n    }\n  ]\n}\n```\n\n---\n\n#### QueryOutput\n```typescript\ninterface QueryOutput {\n  success: boolean;\n  query_type: string;\n  target: string;\n  results: Relationship[];\n}\n\ninterface Relationship {\n  from: string;                   // Source element\n  to: string;                     // Target element\n  type: \"import\" | \"call\" | \"dependency\";\n  file: string;                   // Where relationship exists\n  line?: number;                  // Line number (optional)\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"query_type\": \"imports\",\n  \"target\": \"CheckoutComponent\",\n  \"results\": [\n    {\n      \"from\": \"CheckoutComponent\",\n      \"to\": \"PaymentGateway\",\n      \"type\": \"import\",\n      \"file\": \"src/checkout/Checkout.tsx\",\n      \"line\": 5\n    }\n  ]\n}\n```\n\n---\n\n#### ImpactOutput\n```typescript\ninterface ImpactOutput {\n  success: boolean;\n  element: string;\n  operation: \"modify\" | \"delete\" | \"refactor\";\n  impact: ImpactAnalysis;\n}\n\ninterface ImpactAnalysis {\n  affected_files: number;\n  risk_level: \"LOW\" | \"MEDIUM\" | \"HIGH\" | \"CRITICAL\";\n  ripple_effects: RippleEffect[];\n}\n\ninterface RippleEffect {\n  file: string;                   // Affected file path\n  impact: string;                 // Description (e.g., \"direct call\", \"indirect dependency\")\n  severity?: \"minor\" | \"major\" | \"breaking\";\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\",\n        \"severity\": \"major\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n#### ComplexityOutput\n```typescript\ninterface ComplexityOutput {\n  success: boolean;\n  element: string;\n  note: string;\n  context: ComplexityMetrics;\n}\n\ninterface ComplexityMetrics {\n  lines_of_code: number;\n  cyclomatic_complexity: number;  // Measure of code paths\n  dependencies: number;           // Count of imports/dependencies\n  test_coverage: number;          // Decimal 0.0-1.0 (e.g., 0.65 = 65%)\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"element\": \"ReportGenerator\",\n  \"note\": \"Complexity metrics derived from context generation\",\n  \"context\": {\n    \"lines_of_code\": 245,\n    \"cyclomatic_complexity\": 8,\n    \"dependencies\": 6,\n    \"test_coverage\": 0.65\n  }\n}\n```\n\n---\n\n#### PatternsOutput\n```typescript\ninterface PatternsOutput {\n  success: boolean;\n  pattern_type: string;\n  limit: number;\n  patterns: Record<string, PatternInfo>;\n}\n\ninterface PatternInfo {\n  files: string[];                // Files where pattern appears\n  usage: number;                  // Count of occurrences\n  description?: string;           // Pattern description\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"pattern_type\": \"data-fetching\",\n  \"limit\": 5,\n  \"patterns\": {\n    \"React Query pattern\": {\n      \"files\": [\"src/api/hooks.ts\"],\n      \"usage\": 23,\n      \"description\": \"Async data fetching with caching\"\n    }\n  }\n}\n```\n\n---\n\n#### CoverageOutput\n```typescript\ninterface CoverageOutput {\n  success: boolean;\n  coverage: CoverageReport;\n}\n\ninterface CoverageReport {\n  overall: number;                // Overall coverage % (0.0-1.0)\n  by_file: Record<string, number>; // Per-file coverage\n  untested_files?: string[];      // Files with 0% coverage\n}\n```\n\n**Example:**\n```json\n{\n  \"success\": true,\n  \"coverage\": {\n    \"overall\": 0.72,\n    \"by_file\": {\n      \"src/auth.ts\": 0.85,\n      \"src/checkout.ts\": 0.60\n    },\n    \"untested_files\": [\"src/legacy.ts\"]\n  }\n}\n```\n\n---\n\n#### ContextOutput\n```typescript\ninterface ContextOutput {\n  success: boolean;\n  format: \"json\" | \"markdown\" | \"both\";\n  context: ProjectContext;\n}\n\ninterface ProjectContext {\n  project_summary: string;\n  elements: CodeElement[];\n  dependencies: Record<string, string[]>;\n  test_patterns: Record<string, PatternInfo>;\n  architecture_notes?: string;\n}\n```\n\n---\n\n#### ValidateOutput\n```typescript\ninterface ValidateOutput {\n  success: boolean;\n  pattern: string;\n  validation: ValidationReport;\n}\n\ninterface ValidationReport {\n  valid_references: number;\n  invalid_references: number;\n  errors: ValidationError[];\n}\n\ninterface ValidationError {\n  file: string;\n  line: number;\n  reference: string;\n  error: string;\n}\n```\n\n---\n\n#### DriftOutput\n```typescript\ninterface DriftOutput {\n  success: boolean;\n  drift_report: DriftReport;\n}\n\ninterface DriftReport {\n  added_elements: number;\n  removed_elements: number;\n  modified_elements: number;\n  details?: DriftDetail[];\n}\n\ninterface DriftDetail {\n  element: string;\n  change_type: \"added\" | \"removed\" | \"modified\";\n  file: string;\n}\n```\n\n---\n\n#### DiagramOutput\n```typescript\n// For Mermaid/Dot formats, returns text directly\ntype DiagramOutput = string;\n\n// For JSON format, returns structured graph\ninterface DiagramOutputJSON {\n  success: boolean;\n  diagram: GraphData;\n}\n\ninterface GraphData {\n  nodes: GraphNode[];\n  edges: GraphEdge[];\n}\n\ninterface GraphNode {\n  id: string;\n  label: string;\n  type: \"function\" | \"class\" | \"component\" | \"module\";\n}\n\ninterface GraphEdge {\n  from: string;\n  to: string;\n  label?: string;\n}\n```\n\n---\n\n#### TagOutput\n```typescript\n// Returns plain text output (not JSON)\ntype TagOutput = string;\n\n// Example output:\n// \"Tagged 45 elements in 12 files:\n//  - 18 functions (@Fn)\n//  - 12 classes (@Cl)\n//  - 15 components (@Cp)\"\n```\n\n---\n\n### 3. Error Schemas\n\nAll tools return structured errors on failure:\n\n```typescript\ninterface ToolError {\n  error: string;                  // Human-readable error message\n  code?: string;                  // Error code (e.g., \"TIMEOUT\", \"CLI_NOT_FOUND\")\n  details?: any;                  // Additional context\n}\n```\n\n**Common Error Codes:**\n- `TIMEOUT` - Command exceeded 120s timeout\n- `CLI_NOT_FOUND` - @coderef/core CLI not installed or configured\n- `JSON_PARSE_ERROR` - CLI output malformed\n- `INVALID_INPUT` - Input validation failed\n- `ELEMENT_NOT_FOUND` - Target element doesn't exist\n- `SUBPROCESS_ERROR` - CLI subprocess crashed\n\n**Example:**\n```json\n{\n  \"error\": \"Error: Scan timeout (120s exceeded)\",\n  \"code\": \"TIMEOUT\",\n  \"details\": {\n    \"project_path\": \"/large/project\",\n    \"timeout\": 120\n  }\n}\n```\n\n---\n\n## Why: Schema Design Decisions\n\n### Decision 1: JSON-Only Communication\n**Why:** MCP protocol is JSON-based, @coderef/core CLI supports `--json` flag\n**Benefit:** Type-safe, structured, parseable by agents\n**Alternative Rejected:** Plain text output (harder to parse, error-prone)\n\n### Decision 2: Flat Input Schemas\n**Why:** Simple to validate, easy for agents to construct\n**Benefit:** Fewer nesting errors, clear parameter expectations\n**Alternative Rejected:** Nested object parameters (more complexity)\n\n### Decision 3: Success Boolean\n**Why:** Explicit success/failure distinction\n**Benefit:** Agents can check `success` before processing results\n**Alternative Rejected:** HTTP-style status codes (overkill for local server)\n\n### Decision 4: Enums for Fixed Values\n**Why:** Prevents typos, provides autocomplete hints\n**Benefit:** Compile-time validation, clear API contract\n**Alternative Rejected:** Arbitrary strings (error-prone)\n\n---\n\n## When: Schema Evolution\n\n### Versioning Strategy\nSchema version follows semantic versioning (SemVer):\n- **Major:** Breaking changes (remove fields, change types)\n- **Minor:** Backward-compatible additions (new optional fields)\n- **Patch:** Documentation updates, clarifications\n\n### Current Version: 1.0\n- All 11 tools have stable input/output schemas\n- No breaking changes planned for v1.x series\n\n### Future Schema Changes (v2.0 candidates)\n- Add streaming support for large scan results\n- Add pagination for query results\n- Add optional caching layer with cache keys\n\n---\n\n## Examples\n\n### Example 1: Valid ScanInput\n```json\n{\n  \"project_path\": \"/Users/dev/frontend-app\",\n  \"languages\": [\"ts\", \"tsx\"],\n  \"use_ast\": true\n}\n```\n\n**Validation:** \u2705 Pass\n**Reason:** All required fields present, types correct, AST flag is boolean\n\n---\n\n### Example 2: Invalid QueryInput (Missing target)\n```json\n{\n  \"project_path\": \"/Users/dev/app\",\n  \"query_type\": \"calls-me\"\n}\n```\n\n**Validation:** \u274c Fail\n**Error:** `target parameter is required`\n\n---\n\n### Example 3: Valid ImpactOutput\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\",\n        \"severity\": \"major\"\n      }\n    ]\n  }\n}\n```\n\n**Validation:** \u2705 Pass\n**Reason:** All required fields present, risk_level is valid enum\n\n---\n\n## Relationships & Constraints\n\n### Schema Relationships\n\n```\nScanInput \u2192 ScanOutput \u2192 CodeElement[]\nQueryInput \u2192 QueryOutput \u2192 Relationship[]\nImpactInput \u2192 ImpactOutput \u2192 ImpactAnalysis \u2192 RippleEffect[]\n```\n\n### Cross-Schema Constraints\n\n1. **CodeElement.type** values must match query target types\n2. **QueryOutput.results** must reference valid **CodeElement** names from scan\n3. **ImpactOutput.impact.affected_files** count must match **RippleEffect[]** length\n4. **ComplexityMetrics.test_coverage** must be decimal 0.0-1.0\n\n---\n\n## References\n\n- **[API.md](API.md)** - API endpoint documentation (uses these schemas)\n- **[ARCHITECTURE.md](ARCHITECTURE.md)** - System architecture (data flow through schemas)\n- **[server.py](../server.py)** - Schema validation implementation\n- **[@coderef/core CLI](https://github.com/coderef-system)** - Upstream schema definitions\n\n---\n\n## AI Agent Instructions\n\n**When constructing tool inputs:**\n1. Validate required fields before calling tool (prevent validation errors)\n2. Use enums exactly as defined (avoid typos)\n3. Provide absolute paths for `project_path` (not relative)\n4. Set appropriate timeouts for large projects\n\n**When parsing tool outputs:**\n1. Check `success` field first before accessing results\n2. Handle errors gracefully (retry on TIMEOUT, ask user on CLI_NOT_FOUND)\n3. Validate output schema before using data (defensive parsing)\n4. Extract `CodeElement[]` from scan, then use names in query/impact calls\n\n**Schema validation tips:**\n- TypeScript interfaces above are for documentation\u2014Python server uses JSON Schema internally\n- Missing optional fields default to documented defaults\n- Extra fields are ignored (forward compatibility)\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This schema reference ensures type-safe tool usage. Validate inputs before calling tools to avoid errors.\n",
      "word_count": 1902
    },
    "api": {
      "sections": {
        "api_documentation": "**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---",
        "purpose": "This document describes the MCP (Model Context Protocol) API exposed by the coderef-context server. It provides 11 tools that enable AI agents to understand code structure, dependencies, relationships, impact of changes, complexity metrics, patterns, and test coverage through the @coderef/core CLI.\n\n---",
        "overview": "The coderef-context server exposes code intelligence tools via the MCP protocol (JSON-RPC 2.0). Each tool wraps a @coderef/core CLI command and returns structured JSON responses suitable for agent consumption.\n\n**Base Protocol:** MCP (Model Context Protocol) over stdio\n**Architecture:** Python MCP server \u2192 Node.js subprocess (@coderef/core CLI) \u2192 JSON response\n**Transport:** Standard I/O (stdin/stdout)\n**Authentication:** None (local server, trusted environment)\n\n---",
        "what:_api_endpoints": "### 1. coderef_scan\n\n**Purpose:** Discover all code elements (functions, classes, components, hooks)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"languages\": [\"string\"] (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"]),\n  \"use_ast\": \"boolean\" (optional, default: true)\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\n      \"name\": \"ThemeProvider\",\n      \"type\": \"component\",\n      \"file\": \"src/theme/ThemeProvider.tsx\",\n      \"line\": 10\n    }\n  ]\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef scan <project_path> --lang <langs> --json [--ast]`\n\n---\n\n### 2. coderef_query\n\n**Purpose:** Query code relationships (what-calls, what-imports, shortest-path, etc)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"query_type\": \"enum (required)\" // calls, calls-me, imports, imports-me, depends-on, depends-on-me\n  \"target\": \"string (required)\", // e.g., 'authenticateUser' or 'AuthService#login'\n  \"source\": \"string (optional)\", // For path queries\n  \"max_depth\": \"integer (optional, default: 3)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"results\": [\n    {\n      \"from\": \"CheckoutComponent\",\n      \"to\": \"PaymentGateway\",\n      \"type\": \"import\",\n      \"file\": \"src/checkout/Checkout.tsx\"\n    }\n  ]\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef query <target> --type <type> --depth <depth> --format json`\n\n---\n\n### 3. coderef_impact\n\n**Purpose:** Analyze impact of modifying or deleting a code element\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"element\": \"string (required)\", // e.g., 'AuthService'\n  \"operation\": \"enum (optional, default: modify)\", // modify, delete, refactor\n  \"max_depth\": \"integer (optional, default: 3)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\"\n      }\n    ]\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef impact <element> --depth <depth> --format json`\n\n---\n\n### 4. coderef_complexity\n\n**Purpose:** Get complexity metrics for a code element\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"element\": \"string (required)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"ReportGenerator\",\n  \"note\": \"Complexity metrics derived from context generation\",\n  \"context\": {\n    \"lines_of_code\": 245,\n    \"cyclomatic_complexity\": 8,\n    \"dependencies\": 6,\n    \"test_coverage\": 0.65\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs> --json` (filtered by element)\n\n---\n\n### 5. coderef_patterns\n\n**Purpose:** Discover code patterns and test coverage gaps\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"pattern_type\": \"string (optional)\", // Type of pattern to find\n  \"limit\": \"integer (optional, default: 10)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"pattern_type\": \"data-fetching\",\n  \"limit\": 5,\n  \"patterns\": {\n    \"React Query pattern\": {\n      \"files\": [\"src/api/hooks.ts\"],\n      \"usage\": 23\n    }\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs> --json` (extracts test patterns)\n\n---\n\n### 6. coderef_coverage\n\n**Purpose:** Analyze test coverage in the codebase\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"format\": \"enum (optional, default: summary)\" // summary, detailed\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"coverage\": {\n    \"overall\": 0.72,\n    \"by_file\": {\n      \"src/auth.ts\": 0.85,\n      \"src/checkout.ts\": 0.60\n    }\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef coverage --format json`\n\n---\n\n### 7. coderef_context\n\n**Purpose:** Generate comprehensive codebase context (markdown + JSON)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"languages\": [\"string\"] (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"]),\n  \"output_format\": \"enum (optional, default: json)\" // json, markdown, both\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"format\": \"json\",\n  \"context\": {\n    \"project_summary\": \"...\",\n    \"elements\": [...],\n    \"dependencies\": {...},\n    \"test_patterns\": {...}\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs>`\n\n---\n\n### 8. coderef_validate\n\n**Purpose:** Validate CodeRef2 references in codebase\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"pattern\": \"string (optional, default: **/*.ts)\" // File glob pattern\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"pattern\": \"**/*.ts\",\n  \"validation\": {\n    \"valid_references\": 120,\n    \"invalid_references\": 3,\n    \"errors\": [...]\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef validate <project_path> --pattern <pattern> --format json`\n\n---\n\n### 9. coderef_drift\n\n**Purpose:** Detect drift between CodeRef index and current code\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"index_path\": \"string (optional, default: .coderef-index.json)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"drift_report\": {\n    \"added_elements\": 5,\n    \"removed_elements\": 2,\n    \"modified_elements\": 8\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef drift <project_path> --index <index_path> --format json`\n\n---\n\n### 10. coderef_diagram\n\n**Purpose:** Generate visual dependency diagrams (Mermaid or Graphviz)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"diagram_type\": \"enum (optional, default: dependencies)\", // dependencies, calls, imports, all\n  \"format\": \"enum (optional, default: mermaid)\", // mermaid, dot\n  \"depth\": \"integer (optional, default: 2)\"\n}\n```\n\n**Response:**\n```\ngraph TD\n  A[AuthService] --> B[LoginComponent]\n  A --> C[ProfileComponent]\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef diagram --format <format> --depth <depth>`\n\n---\n\n### 11. coderef_tag\n\n**Purpose:** Add CodeRef2 tags to source files for better tracking and validation\n\n**Input Schema:**\n```json\n{\n  \"path\": \"string (required)\", // File or directory path\n  \"dry_run\": \"boolean (optional, default: false)\",\n  \"force\": \"boolean (optional, default: false)\",\n  \"verbose\": \"boolean (optional, default: false)\",\n  \"update_lineno\": \"boolean (optional, default: false)\",\n  \"include_private\": \"boolean (optional, default: false)\",\n  \"lang\": \"string (optional, default: ts,tsx,js,jsx)\",\n  \"exclude\": \"string (optional)\" // Comma-separated exclusion patterns\n}\n```\n\n**Response:**\n```\nTagged 45 elements in 12 files:\n- 18 functions (@Fn)\n- 12 classes (@Cl)\n- 15 components (@Cp)\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef tag <path> [options]`\n\n---",
        "why:_use_cases": "### UC-1: Discovery (scan)\n**Scenario:** Agent needs to understand what exists in a project before implementing a new feature.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/app\"}}\nResponse: {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\nAgent Decision: \"ThemeProvider exists, I'll extend it instead of creating a new one\"\n```\n\n### UC-2: Dependency Tracing (query)\n**Scenario:** Agent wants to know what depends on a function before refactoring.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_query\", \"args\": {\"query_type\": \"calls-me\", \"target\": \"login\"}}\nResponse: {\"results\": [\"signup.ts\", \"profile.ts\", \"dashboard.ts\"]}\nAgent Decision: \"3 files call login(), I need to update all of them\"\n```\n\n### UC-3: Risk Assessment (impact)\n**Scenario:** Agent evaluates the risk of deleting a service.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_impact\", \"args\": {\"element\": \"AuthService\", \"operation\": \"delete\"}}\nResponse: {\"affected_files\": 12, \"risk_level\": \"MEDIUM\"}\nAgent Decision: \"12 files affected, this is risky. I'll create a comprehensive plan first.\"\n```\n\n---",
        "when:_integration_points": "### Integration with coderef-workflow\nThe coderef-workflow server calls coderef_scan, coderef_query, and coderef_impact during the planning phase (section 0: PREPARATION) to gather project intelligence before creating implementation plans.\n\n### Integration with coderef-personas\nExpert personas (Ava, Marcus, Quinn, etc.) call coderef_query and coderef_impact tools during task execution to make informed decisions about code changes.\n\n### Integration with coderef-docs\nThe coderef-docs server may call coderef_scan to extract real API endpoints, components, and schemas when generating foundation documentation.\n\n---",
        "examples": "### Example 1: Scan a Project\n**Request:**\n```bash",
        "mcp_tool_call_(internal)": "{\n  \"tool\": \"coderef_impact\",\n  \"arguments\": {\n    \"project_path\": \"/Users/dev/app\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\"\n      }\n    ]\n  }\n}\n```\n\n---",
        "error_handling": "### Timeout Errors\nAll tools have a 120-second timeout. If the CLI command exceeds this:\n\n```json\n{\n  \"error\": \"Error: Scan timeout (120s exceeded)\"\n}\n```\n\n**Solution:** Use smaller scope, disable AST analysis (use_ast=false), or increase timeout.\n\n---\n\n### CLI Not Found Errors\nIf the @coderef/core CLI is not installed or configured:\n\n```json\n{\n  \"error\": \"Error: CLI path not found\"\n}\n```\n\n**Solution:** Set CODEREF_CLI_PATH environment variable or install @coderef/core globally.\n\n---\n\n### JSON Parse Errors\nIf CLI output is malformed:\n\n```json\n{\n  \"error\": \"JSON parse error: Unexpected token\"\n}\n```\n\n**Solution:** Check CLI version compatibility, verify CLI works standalone.\n\n---",
        "rate_limits_&_performance": "**Rate Limits:** None (local server, no network)\n**Concurrency:** Unlimited (each tool call spawns independent subprocess)\n**Caching:** None (fresh analysis on each call for accuracy)\n\n**Performance Benchmarks:**\n- `coderef_scan`: ~5-15s for 50k LOC project (AST mode)\n- `coderef_query`: ~1-3s for dependency lookup\n- `coderef_impact`: ~2-5s for impact analysis\n- `coderef_context`: ~10-30s for full project context\n\n---",
        "references": "- **[CLAUDE.md](../CLAUDE.md)** - AI context documentation with architecture details\n- **[README.md](../README.md)** - User-facing overview\n- **[server.py](../server.py)** - MCP server implementation\n- **[@coderef/core](https://github.com/coderef-system)** - Upstream TypeScript analysis engine\n\n---",
        "ai_agent_instructions": "**When using this API:**\n1. Always call `coderef_scan` first to understand what exists before implementing\n2. Use `coderef_query` to trace dependencies before refactoring\n3. Call `coderef_impact` to assess risk before making breaking changes\n4. Leverage `coderef_complexity` for effort estimation\n5. Check `coderef_patterns` to discover existing code patterns (avoid reimplementation)\n\n**Error handling:**\n- Retry once on timeout errors (may be temporary)\n- If CLI not found, ask user to configure CODEREF_CLI_PATH\n- Parse JSON carefully (skip CLI progress messages before JSON)\n\n**Best practices:**\n- Use AST analysis (use_ast=true) for 99% accuracy\n- Set appropriate max_depth (3 is usually sufficient)\n- Combine tools: scan \u2192 query \u2192 impact for comprehensive understanding\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This API enables code intelligence during implementation. Use it to avoid blind coding."
      },
      "full_content": "# API Documentation\n\n**Project:** coderef-context MCP Server\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---\n\n## Purpose\n\nThis document describes the MCP (Model Context Protocol) API exposed by the coderef-context server. It provides 11 tools that enable AI agents to understand code structure, dependencies, relationships, impact of changes, complexity metrics, patterns, and test coverage through the @coderef/core CLI.\n\n---\n\n## Overview\n\nThe coderef-context server exposes code intelligence tools via the MCP protocol (JSON-RPC 2.0). Each tool wraps a @coderef/core CLI command and returns structured JSON responses suitable for agent consumption.\n\n**Base Protocol:** MCP (Model Context Protocol) over stdio\n**Architecture:** Python MCP server \u2192 Node.js subprocess (@coderef/core CLI) \u2192 JSON response\n**Transport:** Standard I/O (stdin/stdout)\n**Authentication:** None (local server, trusted environment)\n\n---\n\n## What: API Endpoints\n\n### 1. coderef_scan\n\n**Purpose:** Discover all code elements (functions, classes, components, hooks)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"languages\": [\"string\"] (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"]),\n  \"use_ast\": \"boolean\" (optional, default: true)\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\n      \"name\": \"ThemeProvider\",\n      \"type\": \"component\",\n      \"file\": \"src/theme/ThemeProvider.tsx\",\n      \"line\": 10\n    }\n  ]\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef scan <project_path> --lang <langs> --json [--ast]`\n\n---\n\n### 2. coderef_query\n\n**Purpose:** Query code relationships (what-calls, what-imports, shortest-path, etc)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"query_type\": \"enum (required)\" // calls, calls-me, imports, imports-me, depends-on, depends-on-me\n  \"target\": \"string (required)\", // e.g., 'authenticateUser' or 'AuthService#login'\n  \"source\": \"string (optional)\", // For path queries\n  \"max_depth\": \"integer (optional, default: 3)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"results\": [\n    {\n      \"from\": \"CheckoutComponent\",\n      \"to\": \"PaymentGateway\",\n      \"type\": \"import\",\n      \"file\": \"src/checkout/Checkout.tsx\"\n    }\n  ]\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef query <target> --type <type> --depth <depth> --format json`\n\n---\n\n### 3. coderef_impact\n\n**Purpose:** Analyze impact of modifying or deleting a code element\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"element\": \"string (required)\", // e.g., 'AuthService'\n  \"operation\": \"enum (optional, default: modify)\", // modify, delete, refactor\n  \"max_depth\": \"integer (optional, default: 3)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\"\n      }\n    ]\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef impact <element> --depth <depth> --format json`\n\n---\n\n### 4. coderef_complexity\n\n**Purpose:** Get complexity metrics for a code element\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"element\": \"string (required)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"ReportGenerator\",\n  \"note\": \"Complexity metrics derived from context generation\",\n  \"context\": {\n    \"lines_of_code\": 245,\n    \"cyclomatic_complexity\": 8,\n    \"dependencies\": 6,\n    \"test_coverage\": 0.65\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs> --json` (filtered by element)\n\n---\n\n### 5. coderef_patterns\n\n**Purpose:** Discover code patterns and test coverage gaps\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"pattern_type\": \"string (optional)\", // Type of pattern to find\n  \"limit\": \"integer (optional, default: 10)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"pattern_type\": \"data-fetching\",\n  \"limit\": 5,\n  \"patterns\": {\n    \"React Query pattern\": {\n      \"files\": [\"src/api/hooks.ts\"],\n      \"usage\": 23\n    }\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs> --json` (extracts test patterns)\n\n---\n\n### 6. coderef_coverage\n\n**Purpose:** Analyze test coverage in the codebase\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"format\": \"enum (optional, default: summary)\" // summary, detailed\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"coverage\": {\n    \"overall\": 0.72,\n    \"by_file\": {\n      \"src/auth.ts\": 0.85,\n      \"src/checkout.ts\": 0.60\n    }\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef coverage --format json`\n\n---\n\n### 7. coderef_context\n\n**Purpose:** Generate comprehensive codebase context (markdown + JSON)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"languages\": [\"string\"] (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"]),\n  \"output_format\": \"enum (optional, default: json)\" // json, markdown, both\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"format\": \"json\",\n  \"context\": {\n    \"project_summary\": \"...\",\n    \"elements\": [...],\n    \"dependencies\": {...},\n    \"test_patterns\": {...}\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef context <project_path> --lang <langs>`\n\n---\n\n### 8. coderef_validate\n\n**Purpose:** Validate CodeRef2 references in codebase\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"pattern\": \"string (optional, default: **/*.ts)\" // File glob pattern\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"pattern\": \"**/*.ts\",\n  \"validation\": {\n    \"valid_references\": 120,\n    \"invalid_references\": 3,\n    \"errors\": [...]\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef validate <project_path> --pattern <pattern> --format json`\n\n---\n\n### 9. coderef_drift\n\n**Purpose:** Detect drift between CodeRef index and current code\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"index_path\": \"string (optional, default: .coderef-index.json)\"\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"drift_report\": {\n    \"added_elements\": 5,\n    \"removed_elements\": 2,\n    \"modified_elements\": 8\n  }\n}\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef drift <project_path> --index <index_path> --format json`\n\n---\n\n### 10. coderef_diagram\n\n**Purpose:** Generate visual dependency diagrams (Mermaid or Graphviz)\n\n**Input Schema:**\n```json\n{\n  \"project_path\": \"string (required)\",\n  \"diagram_type\": \"enum (optional, default: dependencies)\", // dependencies, calls, imports, all\n  \"format\": \"enum (optional, default: mermaid)\", // mermaid, dot\n  \"depth\": \"integer (optional, default: 2)\"\n}\n```\n\n**Response:**\n```\ngraph TD\n  A[AuthService] --> B[LoginComponent]\n  A --> C[ProfileComponent]\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef diagram --format <format> --depth <depth>`\n\n---\n\n### 11. coderef_tag\n\n**Purpose:** Add CodeRef2 tags to source files for better tracking and validation\n\n**Input Schema:**\n```json\n{\n  \"path\": \"string (required)\", // File or directory path\n  \"dry_run\": \"boolean (optional, default: false)\",\n  \"force\": \"boolean (optional, default: false)\",\n  \"verbose\": \"boolean (optional, default: false)\",\n  \"update_lineno\": \"boolean (optional, default: false)\",\n  \"include_private\": \"boolean (optional, default: false)\",\n  \"lang\": \"string (optional, default: ts,tsx,js,jsx)\",\n  \"exclude\": \"string (optional)\" // Comma-separated exclusion patterns\n}\n```\n\n**Response:**\n```\nTagged 45 elements in 12 files:\n- 18 functions (@Fn)\n- 12 classes (@Cl)\n- 15 components (@Cp)\n```\n\n**Timeout:** 120 seconds\n**CLI Command:** `coderef tag <path> [options]`\n\n---\n\n## Why: Use Cases\n\n### UC-1: Discovery (scan)\n**Scenario:** Agent needs to understand what exists in a project before implementing a new feature.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/app\"}}\nResponse: {\"success\": true, \"elements_found\": 247, \"elements\": [...]}\nAgent Decision: \"ThemeProvider exists, I'll extend it instead of creating a new one\"\n```\n\n### UC-2: Dependency Tracing (query)\n**Scenario:** Agent wants to know what depends on a function before refactoring.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_query\", \"args\": {\"query_type\": \"calls-me\", \"target\": \"login\"}}\nResponse: {\"results\": [\"signup.ts\", \"profile.ts\", \"dashboard.ts\"]}\nAgent Decision: \"3 files call login(), I need to update all of them\"\n```\n\n### UC-3: Risk Assessment (impact)\n**Scenario:** Agent evaluates the risk of deleting a service.\n\n**Example:**\n```json\nRequest: {\"tool\": \"coderef_impact\", \"args\": {\"element\": \"AuthService\", \"operation\": \"delete\"}}\nResponse: {\"affected_files\": 12, \"risk_level\": \"MEDIUM\"}\nAgent Decision: \"12 files affected, this is risky. I'll create a comprehensive plan first.\"\n```\n\n---\n\n## When: Integration Points\n\n### Integration with coderef-workflow\nThe coderef-workflow server calls coderef_scan, coderef_query, and coderef_impact during the planning phase (section 0: PREPARATION) to gather project intelligence before creating implementation plans.\n\n### Integration with coderef-personas\nExpert personas (Ava, Marcus, Quinn, etc.) call coderef_query and coderef_impact tools during task execution to make informed decisions about code changes.\n\n### Integration with coderef-docs\nThe coderef-docs server may call coderef_scan to extract real API endpoints, components, and schemas when generating foundation documentation.\n\n---\n\n## Examples\n\n### Example 1: Scan a Project\n**Request:**\n```bash\n# MCP Tool Call (internal)\n{\n  \"tool\": \"coderef_scan\",\n  \"arguments\": {\n    \"project_path\": \"/Users/dev/frontend-app\",\n    \"languages\": [\"ts\", \"tsx\"],\n    \"use_ast\": true\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\n      \"name\": \"ThemeProvider\",\n      \"type\": \"component\",\n      \"file\": \"src/theme/ThemeProvider.tsx\",\n      \"line\": 10\n    },\n    {\n      \"name\": \"useTheme\",\n      \"type\": \"hook\",\n      \"file\": \"src/theme/useTheme.ts\",\n      \"line\": 5\n    }\n  ]\n}\n```\n\n---\n\n### Example 2: Query Dependencies\n**Request:**\n```bash\n# MCP Tool Call (internal)\n{\n  \"tool\": \"coderef_query\",\n  \"arguments\": {\n    \"project_path\": \"/Users/dev/checkout-app\",\n    \"query_type\": \"imports\",\n    \"target\": \"CheckoutComponent\"\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"query_type\": \"imports\",\n  \"target\": \"CheckoutComponent\",\n  \"results\": [\n    {\n      \"from\": \"CheckoutComponent\",\n      \"to\": \"PaymentGateway\",\n      \"type\": \"import\",\n      \"file\": \"src/checkout/Checkout.tsx\"\n    }\n  ]\n}\n```\n\n---\n\n### Example 3: Assess Impact\n**Request:**\n```bash\n# MCP Tool Call (internal)\n{\n  \"tool\": \"coderef_impact\",\n  \"arguments\": {\n    \"project_path\": \"/Users/dev/app\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n  }\n}\n```\n\n**Response:**\n```json\n{\n  \"success\": true,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [\n      {\n        \"file\": \"src/login/Login.tsx\",\n        \"impact\": \"direct call\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n## Error Handling\n\n### Timeout Errors\nAll tools have a 120-second timeout. If the CLI command exceeds this:\n\n```json\n{\n  \"error\": \"Error: Scan timeout (120s exceeded)\"\n}\n```\n\n**Solution:** Use smaller scope, disable AST analysis (use_ast=false), or increase timeout.\n\n---\n\n### CLI Not Found Errors\nIf the @coderef/core CLI is not installed or configured:\n\n```json\n{\n  \"error\": \"Error: CLI path not found\"\n}\n```\n\n**Solution:** Set CODEREF_CLI_PATH environment variable or install @coderef/core globally.\n\n---\n\n### JSON Parse Errors\nIf CLI output is malformed:\n\n```json\n{\n  \"error\": \"JSON parse error: Unexpected token\"\n}\n```\n\n**Solution:** Check CLI version compatibility, verify CLI works standalone.\n\n---\n\n## Rate Limits & Performance\n\n**Rate Limits:** None (local server, no network)\n**Concurrency:** Unlimited (each tool call spawns independent subprocess)\n**Caching:** None (fresh analysis on each call for accuracy)\n\n**Performance Benchmarks:**\n- `coderef_scan`: ~5-15s for 50k LOC project (AST mode)\n- `coderef_query`: ~1-3s for dependency lookup\n- `coderef_impact`: ~2-5s for impact analysis\n- `coderef_context`: ~10-30s for full project context\n\n---\n\n## References\n\n- **[CLAUDE.md](../CLAUDE.md)** - AI context documentation with architecture details\n- **[README.md](../README.md)** - User-facing overview\n- **[server.py](../server.py)** - MCP server implementation\n- **[@coderef/core](https://github.com/coderef-system)** - Upstream TypeScript analysis engine\n\n---\n\n## AI Agent Instructions\n\n**When using this API:**\n1. Always call `coderef_scan` first to understand what exists before implementing\n2. Use `coderef_query` to trace dependencies before refactoring\n3. Call `coderef_impact` to assess risk before making breaking changes\n4. Leverage `coderef_complexity` for effort estimation\n5. Check `coderef_patterns` to discover existing code patterns (avoid reimplementation)\n\n**Error handling:**\n- Retry once on timeout errors (may be temporary)\n- If CLI not found, ask user to configure CODEREF_CLI_PATH\n- Parse JSON carefully (skip CLI progress messages before JSON)\n\n**Best practices:**\n- Use AST analysis (use_ast=true) for 99% accuracy\n- Set appropriate max_depth (3 is usually sufficient)\n- Combine tools: scan \u2192 query \u2192 impact for comprehensive understanding\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This API enables code intelligence during implementation. Use it to avoid blind coding.\n",
      "word_count": 1625
    },
    "components": {
      "sections": {
        "components_documentation": "**Project:** coderef-context MCP Server\n**Framework:** Python MCP Server (asyncio-based)\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---",
        "purpose": "This document catalogs the reusable components (tool handlers, utilities, and patterns) within the coderef-context MCP server. It provides a reference for understanding the modular architecture and how to extend the server with new tools or functionality.\n\n**Note:** This is a Python server (not a UI framework like React), so \"components\" refers to **modular code units** (functions, classes, patterns) rather than UI components.\n\n---",
        "overview": "The coderef-context server follows a **handler-based architecture** where each MCP tool is implemented as an independent async handler function. This modular design allows:\n- Easy addition of new tools (add handler + registration)\n- Independent testing of each tool\n- Consistent error handling patterns\n- Parallel execution of multiple tool calls\n\n---",
        "what:_component_inventory": "### 1. Core Components\n\n#### 1.1 MCP Server (server.py)\n\n**Purpose:** Main entry point and MCP protocol implementation\n\n**Key Responsibilities:**\n- Register MCP tools via `@app.list_tools()`\n- Route tool calls to appropriate handlers via `@app.call_tool()`\n- Manage server lifecycle (startup, shutdown)\n\n**Code Example:**\n```python\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\napp = Server(\"coderef-context\")\n\n@app.list_tools()\nasync def list_tools() -> List[Tool]:\n    return [\n        Tool(name=\"coderef_scan\", description=\"...\", inputSchema={...}),\n        # ... 10 more tools\n    ]\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict) -> list[TextContent]:\n    if name == \"coderef_scan\":\n        return await handle_coderef_scan(arguments)\n    # ... route to other handlers\n```\n\n**Dependencies:** `mcp`, `mcp.server.stdio`\n\n---\n\n#### 1.2 CLI Command Manager (get_cli_command)\n\n**Purpose:** Smart CLI path detection and fallback logic\n\n**Logic Flow:**\n1. Check if `coderef` is globally installed (via `where` on Windows, `which` on Unix)\n2. Test if global install actually works (`coderef --version`)\n3. Fall back to local development path (`CODEREF_CLI_PATH` environment variable)\n4. Final fallback: Try `coderef` command (may fail if not installed)\n\n**Code Example:**\n```python\ndef get_cli_command():\n    \"\"\"Get the CLI command, checking global install first.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"where\", \"coderef\"] if os.name == \"nt\" else [\"which\", \"coderef\"],\n            capture_output=True, text=True, timeout=5\n        )\n        if result.returncode == 0:\n            test_result = subprocess.run([\"coderef\", \"--version\"], capture_output=True, timeout=5)\n            if test_result.returncode == 0:\n                return [\"coderef\"]\n    except Exception as e:\n        print(f\"Global coderef check failed: {e}\")\n\n    # Fall back to local path\n    cli_path = os.environ.get(\"CODEREF_CLI_PATH\", default_path)\n    cli_bin = os.path.join(cli_path, \"dist\", \"cli.js\")\n    if os.path.exists(cli_bin):\n        return [\"node\", cli_bin]\n\n    return [\"coderef\"]\n\nCLI_COMMAND = get_cli_command()\n```\n\n**Usage:** Called once at startup, result stored in `CLI_COMMAND` global\n\n---\n\n### 2. Tool Handler Components\n\nAll tool handlers follow a **standard async pattern**:\n\n#### Handler Pattern Template\n```python\nasync def handle_coderef_<tool>(args: dict) -> list[TextContent]:\n    \"\"\"Handle /<tool> tool - <description>.\n\n    Uses async subprocess to prevent blocking the event loop.\n    Timeout: <N>s (allows for <use case>).\n    \"\"\"\n    # 1. Extract and validate arguments\n    project_path = args.get(\"project_path\", \".\")\n    param1 = args.get(\"param1\")\n    param2 = args.get(\"param2\", default_value)\n\n    if not required_param:\n        return [TextContent(type=\"text\", text=\"Error: required_param is required\")]\n\n    # 2. Build CLI command\n    cmd = [\n        *CLI_COMMAND, \"<cli-command>\",\n        project_path,\n        \"--flag1\", param1,\n        \"--flag2\", str(param2),\n        \"--json\"\n    ]\n\n    try:\n        # 3. Execute async subprocess\n        process = await asyncio.create_subprocess_exec(\n            *cmd,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n            cwd=project_path  # Optional: set working directory\n        )\n\n        # 4. Wait with timeout\n        try:\n            stdout, stderr = await asyncio.wait_for(\n                process.communicate(),\n                timeout=120\n            )\n        except asyncio.TimeoutError:\n            process.kill()\n            await process.wait()\n            return [TextContent(type=\"text\", text=\"Error: Timeout (120s exceeded)\")]\n\n        # 5. Check return code\n        if process.returncode != 0:\n            return [TextContent(type=\"text\", text=f\"Error: {stderr.decode()}\")]\n\n        # 6. Parse JSON output (with error handling)\n        try:\n            stdout_text = stdout.decode()\n            # Skip CLI progress messages before JSON\n            json_start = stdout_text.find('[') or stdout_text.find('{')\n            if json_start >= 0:\n                stdout_text = stdout_text[json_start:]\n            data = json.loads(stdout_text)\n\n            # 7. Return structured response\n            return [TextContent(type=\"text\", text=json.dumps({\n                \"success\": True,\n                \"result_field\": data\n            }, indent=2))]\n        except json.JSONDecodeError as e:\n            return [TextContent(type=\"text\", text=f\"JSON parse error: {str(e)}\")]\n\n    except Exception as e:\n        return [TextContent(type=\"text\", text=f\"Error: {str(e)}\")]\n```\n\n**Key Properties:**\n- \u2705 **Async/await** - Non-blocking subprocess execution\n- \u2705 **Timeout handling** - Prevents infinite hangs (120s default)\n- \u2705 **Error handling** - Graceful degradation with clear error messages\n- \u2705 **JSON parsing** - Skips CLI progress messages, validates JSON\n- \u2705 **Structured responses** - Consistent `{success: true, ...}` format\n\n---\n\n#### 2.1 Scan Handler (handle_coderef_scan)\n\n**Purpose:** Discover all code elements in a project\n\n**Inputs:**\n- `project_path` (required)\n- `languages` (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"])\n- `use_ast` (optional, default: true)\n\n**CLI Command Built:**\n```bash\ncoderef scan <project_path> --lang ts,tsx --json [--ast]\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\"name\": \"ThemeProvider\", \"type\": \"component\", \"file\": \"src/theme/ThemeProvider.tsx\", \"line\": 10}\n  ]\n}\n```\n\n**Code Location:** server.py:434-494\n\n---\n\n#### 2.2 Query Handler (handle_coderef_query)\n\n**Purpose:** Query code relationships (calls, imports, dependencies)\n\n**Inputs:**\n- `project_path` (required)\n- `query_type` (required: calls, calls-me, imports, imports-me, depends-on, depends-on-me)\n- `target` (required: element to query)\n- `max_depth` (optional, default: 3)\n\n**CLI Command Built:**\n```bash\ncoderef query <target> --type <type> --depth <depth> --format json\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"results\": [\n    {\"from\": \"CheckoutComponent\", \"to\": \"PaymentGateway\", \"type\": \"import\", \"file\": \"...\"}\n  ]\n}\n```\n\n**Code Location:** server.py:497-560\n\n---\n\n#### 2.3 Impact Handler (handle_coderef_impact)\n\n**Purpose:** Analyze impact of changing a code element\n\n**Inputs:**\n- `project_path` (required)\n- `element` (required: element to analyze)\n- `operation` (optional: modify, delete, refactor)\n- `max_depth` (optional, default: 3)\n\n**CLI Command Built:**\n```bash\ncoderef impact <element> --depth <depth> --format json\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [...]\n  }\n}\n```\n\n**Code Location:** server.py:563-618\n\n---\n\n#### 2.4 Complexity Handler (handle_coderef_complexity)\n\n**Purpose:** Get complexity metrics for a code element\n\n**Inputs:**\n- `project_path` (required)\n- `element` (required)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx --json\n```\n\n**Note:** Complexity is derived from context generation (no dedicated CLI command)\n\n**Code Location:** server.py:621-676\n\n---\n\n#### 2.5 Patterns Handler (handle_coderef_patterns)\n\n**Purpose:** Discover code patterns and test coverage gaps\n\n**Inputs:**\n- `project_path` (required)\n- `pattern_type` (optional)\n- `limit` (optional, default: 10)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx --json\n```\n\n**Note:** Patterns are extracted from context generation's `testPatterns` field\n\n**Code Location:** server.py:679-730\n\n---\n\n#### 2.6 Coverage Handler (handle_coderef_coverage)\n\n**Purpose:** Analyze test coverage\n\n**Inputs:**\n- `project_path` (required)\n- `format` (optional: summary, detailed)\n\n**CLI Command Built:**\n```bash\ncoderef coverage --format json\n```\n\n**Code Location:** server.py:733-779\n\n---\n\n#### 2.7 Context Handler (handle_coderef_context)\n\n**Purpose:** Generate comprehensive codebase context\n\n**Inputs:**\n- `project_path` (required)\n- `languages` (optional)\n- `output_format` (optional: json, markdown, both)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx\n```\n\n**Code Location:** server.py:782-831\n\n---\n\n#### 2.8 Validate Handler (handle_coderef_validate)\n\n**Purpose:** Validate CodeRef2 references in codebase\n\n**Inputs:**\n- `project_path` (required)\n- `pattern` (optional, default: \"**/*.ts\")\n\n**CLI Command Built:**\n```bash\ncoderef validate <project_path> --pattern <pattern> --format json\n```\n\n**Code Location:** server.py:834-883\n\n---\n\n#### 2.9 Drift Handler (handle_coderef_drift)\n\n**Purpose:** Detect drift between CodeRef index and current code\n\n**Inputs:**\n- `project_path` (required)\n- `index_path` (optional, default: \".coderef-index.json\")\n\n**CLI Command Built:**\n```bash\ncoderef drift <project_path> --index <index_path> --format json\n```\n\n**Code Location:** server.py:886-934\n\n---\n\n#### 2.10 Diagram Handler (handle_coderef_diagram)\n\n**Purpose:** Generate visual dependency diagrams\n\n**Inputs:**\n- `project_path` (required)\n- `diagram_type` (optional: dependencies, calls, imports, all)\n- `format` (optional: mermaid, dot)\n- `depth` (optional, default: 2)\n\n**CLI Command Built:**\n```bash\ncoderef diagram --format <format> --depth <depth>\n```\n\n**Special Handling:** Returns text directly for mermaid/dot, parses JSON for json format\n\n**Code Location:** server.py:937-994\n\n---\n\n#### 2.11 Tag Handler (handle_coderef_tag)\n\n**Purpose:** Add CodeRef2 tags to source files\n\n**Inputs:**\n- `path` (required: file or directory path)\n- `dry_run`, `force`, `verbose`, `update_lineno`, `include_private` (optional boolean flags)\n- `lang`, `exclude` (optional string parameters)\n\n**CLI Command Built:**\n```bash\ncoderef tag <path> [--dry-run] [--force] [--verbose] [--update-lineno] [--include-private] [--lang <langs>] [--exclude <patterns>]\n```\n\n**Special Handling:** Returns plain text output (not JSON)\n\n**Code Location:** server.py:997-1054\n\n---\n\n### 3. Utility Components\n\n#### 3.1 JSON Parser with Progress Skipping\n\n**Purpose:** Parse CLI JSON output while ignoring progress messages\n\n**Pattern:**\n```python\nstdout_text = stdout.decode()",
        "skip_lines_until_we_find_json_array_or_object": "json_start = stdout_text.find('[')\nif json_start == -1:\n    json_start = stdout_text.find('{')\nif json_start >= 0:\n    stdout_text = stdout_text[json_start:]\ndata = json.loads(stdout_text)\n```\n\n**Why:** @coderef/core CLI may output progress messages before JSON\n\n**Used By:** All handlers except diagram/tag (which return text)\n\n---\n\n#### 3.2 Async Subprocess Pattern\n\n**Purpose:** Non-blocking subprocess execution with timeout\n\n**Pattern:**\n```python\nprocess = await asyncio.create_subprocess_exec(\n    *cmd,\n    stdout=asyncio.subprocess.PIPE,\n    stderr=asyncio.subprocess.PIPE,\n    cwd=project_path  # Optional\n)\n\ntry:\n    stdout, stderr = await asyncio.wait_for(\n        process.communicate(),\n        timeout=120\n    )\nexcept asyncio.TimeoutError:\n    process.kill()\n    await process.wait()\n    return [TextContent(type=\"text\", text=\"Error: Timeout\")]\n```\n\n**Why:** Prevents event loop blocking, allows concurrent tool calls\n\n**Used By:** All 11 tool handlers\n\n---",
        "why:_component_design_decisions": "### Decision 1: Handler Functions (Not Classes)\n**Why:** Simpler, functional approach; no shared state needed\n**Benefit:** Easy to test, no side effects, clear inputs/outputs\n**Alternative Rejected:** Class-based handlers (unnecessary complexity)\n\n### Decision 2: Async/Await Throughout\n**Why:** MCP protocol is async, subprocess I/O is async\n**Benefit:** Non-blocking, supports concurrent agent requests\n**Alternative Rejected:** Threading (more complex, less Pythonic)\n\n### Decision 3: Subprocess Isolation\n**Why:** Separate Node.js CLI from Python MCP server\n**Benefit:** One CLI crash doesn't crash server, clean separation\n**Alternative Rejected:** In-process CLI (would require Node.js bridge)\n\n### Decision 4: Consistent Error Handling\n**Why:** All handlers follow same pattern (try/except, timeout, JSON parse)\n**Benefit:** Predictable behavior, easier debugging\n**Alternative Rejected:** Per-handler error handling (inconsistent UX)\n\n---",
        "when:_adding_new_components": "### How to Add a New Tool Handler\n\n1. **Define Tool Schema** (in `@app.list_tools()`)\n```python\nTool(\n    name=\"coderef_newtool\",\n    description=\"What this tool does\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"project_path\": {\"type\": \"string\", \"description\": \"...\"},\n            \"param1\": {\"type\": \"string\", \"description\": \"...\"}\n        },\n        \"required\": [\"project_path\"]\n    }\n)\n```\n\n2. **Add Handler Function**\n```python\nasync def handle_coderef_newtool(args: dict) -> list[TextContent]:\n    \"\"\"Handle /newtool tool - description.\"\"\"\n    project_path = args.get(\"project_path\", \".\")\n    param1 = args.get(\"param1\")\n\n    cmd = [*CLI_COMMAND, \"newtool\", project_path, \"--param1\", param1, \"--json\"]\n\n    # ... follow async subprocess pattern ...\n```\n\n3. **Register in call_tool Router**\n```python\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict) -> list[TextContent]:\n    try:\n        if name == \"coderef_newtool\":\n            return await handle_coderef_newtool(arguments)\n        # ... other handlers ...\n```\n\n4. **Test with Real CLI**\n```python",
        "manual_test": "python server.py",
        "in_another_terminal:": "echo '{\"tool\": \"coderef_newtool\", \"args\": {\"project_path\": \"/path/to/project\"}}' | python -m mcp.client\n```\n\n---",
        "examples": "### Example 1: Using Scan Handler\n```python",
        "agent_calls_scan_tool": "args = {\n    \"project_path\": \"/Users/dev/frontend-app\",\n    \"languages\": [\"ts\", \"tsx\"],\n    \"use_ast\": True\n}\n\nresponse = await handle_coderef_scan(args)",
        "[textcontent(type=\"text\",_text='{\"success\":_true,_\"elements_found\":_247,_...}')]": "```\n\n---\n\n### Example 2: Using Query Handler\n```python",
        "agent_calls_query_tool": "args = {\n    \"project_path\": \"/Users/dev/app\",\n    \"query_type\": \"calls-me\",\n    \"target\": \"login\"\n}\n\nresponse = await handle_coderef_query(args)",
        "[textcontent(type=\"text\",_text='{\"success\":_true,_\"results\":_[...]}')]": "```\n\n---\n\n### Example 3: Error Handling Pattern\n```python",
        "timeout_scenario": "args = {\"project_path\": \"/very/large/project\"}\n\nresponse = await handle_coderef_scan(args)",
        "[textcontent(type=\"text\",_text=\"error:_scan_timeout_(120s_exceeded)\")]": "",
        "cli_not_found_scenario": "response = await handle_coderef_scan(args)",
        "[textcontent(type=\"text\",_text=\"error:_[errno_2]_no_such_file_or_directory:_'coderef'\")]": "```\n\n---",
        "state_management": "**Server State:** Stateless\n- No shared state between tool calls\n- Each handler is independent\n- No caching (intentional for accuracy)\n\n**CLI State:** External\n- @coderef/core CLI may maintain `.coderef-index.json` cache\n- MCP server doesn't manage this state\n- Fresh subprocess on each tool call\n\n---",
        "references": "- **[API.md](API.md)** - API endpoint documentation (tool schemas)\n- **[SCHEMA.md](SCHEMA.md)** - Data schema definitions (input/output types)\n- **[ARCHITECTURE.md](ARCHITECTURE.md)** - System architecture (component interactions)\n- **[server.py](../server.py)** - Full implementation source code\n\n---",
        "ai_agent_instructions": "**When extending this server:**\n1. Follow the handler pattern template exactly (async, timeout, JSON parse, error handling)\n2. Register new tools in both `list_tools()` and `call_tool()` router\n3. Test with real @coderef/core CLI before committing\n4. Document new tools in API.md and update SCHEMA.md\n\n**When debugging handlers:**\n1. Check CLI command construction first (print `cmd` variable)\n2. Run CLI command manually to verify it works standalone\n3. Check timeout duration (large projects need more time)\n4. Verify JSON parsing logic (skip progress messages correctly)\n\n**Best practices:**\n- Keep handlers pure (no side effects, no shared state)\n- Use descriptive error messages (help agents diagnose issues)\n- Always validate required parameters before subprocess execution\n- Return structured JSON (consistency across all tools)\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This component reference helps you understand the modular architecture and extend the server with new code intelligence tools."
      },
      "full_content": "# Components Documentation\n\n**Project:** coderef-context MCP Server\n**Framework:** Python MCP Server (asyncio-based)\n**Version:** 1.1.0\n**Last Updated:** 2025-12-30\n**Status:** \u2705 Production\n\n---\n\n## Purpose\n\nThis document catalogs the reusable components (tool handlers, utilities, and patterns) within the coderef-context MCP server. It provides a reference for understanding the modular architecture and how to extend the server with new tools or functionality.\n\n**Note:** This is a Python server (not a UI framework like React), so \"components\" refers to **modular code units** (functions, classes, patterns) rather than UI components.\n\n---\n\n## Overview\n\nThe coderef-context server follows a **handler-based architecture** where each MCP tool is implemented as an independent async handler function. This modular design allows:\n- Easy addition of new tools (add handler + registration)\n- Independent testing of each tool\n- Consistent error handling patterns\n- Parallel execution of multiple tool calls\n\n---\n\n## What: Component Inventory\n\n### 1. Core Components\n\n#### 1.1 MCP Server (server.py)\n\n**Purpose:** Main entry point and MCP protocol implementation\n\n**Key Responsibilities:**\n- Register MCP tools via `@app.list_tools()`\n- Route tool calls to appropriate handlers via `@app.call_tool()`\n- Manage server lifecycle (startup, shutdown)\n\n**Code Example:**\n```python\nfrom mcp.server import Server\nfrom mcp.server.stdio import stdio_server\n\napp = Server(\"coderef-context\")\n\n@app.list_tools()\nasync def list_tools() -> List[Tool]:\n    return [\n        Tool(name=\"coderef_scan\", description=\"...\", inputSchema={...}),\n        # ... 10 more tools\n    ]\n\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict) -> list[TextContent]:\n    if name == \"coderef_scan\":\n        return await handle_coderef_scan(arguments)\n    # ... route to other handlers\n```\n\n**Dependencies:** `mcp`, `mcp.server.stdio`\n\n---\n\n#### 1.2 CLI Command Manager (get_cli_command)\n\n**Purpose:** Smart CLI path detection and fallback logic\n\n**Logic Flow:**\n1. Check if `coderef` is globally installed (via `where` on Windows, `which` on Unix)\n2. Test if global install actually works (`coderef --version`)\n3. Fall back to local development path (`CODEREF_CLI_PATH` environment variable)\n4. Final fallback: Try `coderef` command (may fail if not installed)\n\n**Code Example:**\n```python\ndef get_cli_command():\n    \"\"\"Get the CLI command, checking global install first.\"\"\"\n    try:\n        result = subprocess.run(\n            [\"where\", \"coderef\"] if os.name == \"nt\" else [\"which\", \"coderef\"],\n            capture_output=True, text=True, timeout=5\n        )\n        if result.returncode == 0:\n            test_result = subprocess.run([\"coderef\", \"--version\"], capture_output=True, timeout=5)\n            if test_result.returncode == 0:\n                return [\"coderef\"]\n    except Exception as e:\n        print(f\"Global coderef check failed: {e}\")\n\n    # Fall back to local path\n    cli_path = os.environ.get(\"CODEREF_CLI_PATH\", default_path)\n    cli_bin = os.path.join(cli_path, \"dist\", \"cli.js\")\n    if os.path.exists(cli_bin):\n        return [\"node\", cli_bin]\n\n    return [\"coderef\"]\n\nCLI_COMMAND = get_cli_command()\n```\n\n**Usage:** Called once at startup, result stored in `CLI_COMMAND` global\n\n---\n\n### 2. Tool Handler Components\n\nAll tool handlers follow a **standard async pattern**:\n\n#### Handler Pattern Template\n```python\nasync def handle_coderef_<tool>(args: dict) -> list[TextContent]:\n    \"\"\"Handle /<tool> tool - <description>.\n\n    Uses async subprocess to prevent blocking the event loop.\n    Timeout: <N>s (allows for <use case>).\n    \"\"\"\n    # 1. Extract and validate arguments\n    project_path = args.get(\"project_path\", \".\")\n    param1 = args.get(\"param1\")\n    param2 = args.get(\"param2\", default_value)\n\n    if not required_param:\n        return [TextContent(type=\"text\", text=\"Error: required_param is required\")]\n\n    # 2. Build CLI command\n    cmd = [\n        *CLI_COMMAND, \"<cli-command>\",\n        project_path,\n        \"--flag1\", param1,\n        \"--flag2\", str(param2),\n        \"--json\"\n    ]\n\n    try:\n        # 3. Execute async subprocess\n        process = await asyncio.create_subprocess_exec(\n            *cmd,\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n            cwd=project_path  # Optional: set working directory\n        )\n\n        # 4. Wait with timeout\n        try:\n            stdout, stderr = await asyncio.wait_for(\n                process.communicate(),\n                timeout=120\n            )\n        except asyncio.TimeoutError:\n            process.kill()\n            await process.wait()\n            return [TextContent(type=\"text\", text=\"Error: Timeout (120s exceeded)\")]\n\n        # 5. Check return code\n        if process.returncode != 0:\n            return [TextContent(type=\"text\", text=f\"Error: {stderr.decode()}\")]\n\n        # 6. Parse JSON output (with error handling)\n        try:\n            stdout_text = stdout.decode()\n            # Skip CLI progress messages before JSON\n            json_start = stdout_text.find('[') or stdout_text.find('{')\n            if json_start >= 0:\n                stdout_text = stdout_text[json_start:]\n            data = json.loads(stdout_text)\n\n            # 7. Return structured response\n            return [TextContent(type=\"text\", text=json.dumps({\n                \"success\": True,\n                \"result_field\": data\n            }, indent=2))]\n        except json.JSONDecodeError as e:\n            return [TextContent(type=\"text\", text=f\"JSON parse error: {str(e)}\")]\n\n    except Exception as e:\n        return [TextContent(type=\"text\", text=f\"Error: {str(e)}\")]\n```\n\n**Key Properties:**\n- \u2705 **Async/await** - Non-blocking subprocess execution\n- \u2705 **Timeout handling** - Prevents infinite hangs (120s default)\n- \u2705 **Error handling** - Graceful degradation with clear error messages\n- \u2705 **JSON parsing** - Skips CLI progress messages, validates JSON\n- \u2705 **Structured responses** - Consistent `{success: true, ...}` format\n\n---\n\n#### 2.1 Scan Handler (handle_coderef_scan)\n\n**Purpose:** Discover all code elements in a project\n\n**Inputs:**\n- `project_path` (required)\n- `languages` (optional, default: [\"ts\", \"tsx\", \"js\", \"jsx\"])\n- `use_ast` (optional, default: true)\n\n**CLI Command Built:**\n```bash\ncoderef scan <project_path> --lang ts,tsx --json [--ast]\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"elements_found\": 247,\n  \"elements\": [\n    {\"name\": \"ThemeProvider\", \"type\": \"component\", \"file\": \"src/theme/ThemeProvider.tsx\", \"line\": 10}\n  ]\n}\n```\n\n**Code Location:** server.py:434-494\n\n---\n\n#### 2.2 Query Handler (handle_coderef_query)\n\n**Purpose:** Query code relationships (calls, imports, dependencies)\n\n**Inputs:**\n- `project_path` (required)\n- `query_type` (required: calls, calls-me, imports, imports-me, depends-on, depends-on-me)\n- `target` (required: element to query)\n- `max_depth` (optional, default: 3)\n\n**CLI Command Built:**\n```bash\ncoderef query <target> --type <type> --depth <depth> --format json\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"query_type\": \"calls-me\",\n  \"target\": \"login\",\n  \"results\": [\n    {\"from\": \"CheckoutComponent\", \"to\": \"PaymentGateway\", \"type\": \"import\", \"file\": \"...\"}\n  ]\n}\n```\n\n**Code Location:** server.py:497-560\n\n---\n\n#### 2.3 Impact Handler (handle_coderef_impact)\n\n**Purpose:** Analyze impact of changing a code element\n\n**Inputs:**\n- `project_path` (required)\n- `element` (required: element to analyze)\n- `operation` (optional: modify, delete, refactor)\n- `max_depth` (optional, default: 3)\n\n**CLI Command Built:**\n```bash\ncoderef impact <element> --depth <depth> --format json\n```\n\n**Output Structure:**\n```python\n{\n  \"success\": True,\n  \"element\": \"AuthService\",\n  \"operation\": \"refactor\",\n  \"impact\": {\n    \"affected_files\": 12,\n    \"risk_level\": \"MEDIUM\",\n    \"ripple_effects\": [...]\n  }\n}\n```\n\n**Code Location:** server.py:563-618\n\n---\n\n#### 2.4 Complexity Handler (handle_coderef_complexity)\n\n**Purpose:** Get complexity metrics for a code element\n\n**Inputs:**\n- `project_path` (required)\n- `element` (required)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx --json\n```\n\n**Note:** Complexity is derived from context generation (no dedicated CLI command)\n\n**Code Location:** server.py:621-676\n\n---\n\n#### 2.5 Patterns Handler (handle_coderef_patterns)\n\n**Purpose:** Discover code patterns and test coverage gaps\n\n**Inputs:**\n- `project_path` (required)\n- `pattern_type` (optional)\n- `limit` (optional, default: 10)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx --json\n```\n\n**Note:** Patterns are extracted from context generation's `testPatterns` field\n\n**Code Location:** server.py:679-730\n\n---\n\n#### 2.6 Coverage Handler (handle_coderef_coverage)\n\n**Purpose:** Analyze test coverage\n\n**Inputs:**\n- `project_path` (required)\n- `format` (optional: summary, detailed)\n\n**CLI Command Built:**\n```bash\ncoderef coverage --format json\n```\n\n**Code Location:** server.py:733-779\n\n---\n\n#### 2.7 Context Handler (handle_coderef_context)\n\n**Purpose:** Generate comprehensive codebase context\n\n**Inputs:**\n- `project_path` (required)\n- `languages` (optional)\n- `output_format` (optional: json, markdown, both)\n\n**CLI Command Built:**\n```bash\ncoderef context <project_path> --lang ts,tsx,js,jsx\n```\n\n**Code Location:** server.py:782-831\n\n---\n\n#### 2.8 Validate Handler (handle_coderef_validate)\n\n**Purpose:** Validate CodeRef2 references in codebase\n\n**Inputs:**\n- `project_path` (required)\n- `pattern` (optional, default: \"**/*.ts\")\n\n**CLI Command Built:**\n```bash\ncoderef validate <project_path> --pattern <pattern> --format json\n```\n\n**Code Location:** server.py:834-883\n\n---\n\n#### 2.9 Drift Handler (handle_coderef_drift)\n\n**Purpose:** Detect drift between CodeRef index and current code\n\n**Inputs:**\n- `project_path` (required)\n- `index_path` (optional, default: \".coderef-index.json\")\n\n**CLI Command Built:**\n```bash\ncoderef drift <project_path> --index <index_path> --format json\n```\n\n**Code Location:** server.py:886-934\n\n---\n\n#### 2.10 Diagram Handler (handle_coderef_diagram)\n\n**Purpose:** Generate visual dependency diagrams\n\n**Inputs:**\n- `project_path` (required)\n- `diagram_type` (optional: dependencies, calls, imports, all)\n- `format` (optional: mermaid, dot)\n- `depth` (optional, default: 2)\n\n**CLI Command Built:**\n```bash\ncoderef diagram --format <format> --depth <depth>\n```\n\n**Special Handling:** Returns text directly for mermaid/dot, parses JSON for json format\n\n**Code Location:** server.py:937-994\n\n---\n\n#### 2.11 Tag Handler (handle_coderef_tag)\n\n**Purpose:** Add CodeRef2 tags to source files\n\n**Inputs:**\n- `path` (required: file or directory path)\n- `dry_run`, `force`, `verbose`, `update_lineno`, `include_private` (optional boolean flags)\n- `lang`, `exclude` (optional string parameters)\n\n**CLI Command Built:**\n```bash\ncoderef tag <path> [--dry-run] [--force] [--verbose] [--update-lineno] [--include-private] [--lang <langs>] [--exclude <patterns>]\n```\n\n**Special Handling:** Returns plain text output (not JSON)\n\n**Code Location:** server.py:997-1054\n\n---\n\n### 3. Utility Components\n\n#### 3.1 JSON Parser with Progress Skipping\n\n**Purpose:** Parse CLI JSON output while ignoring progress messages\n\n**Pattern:**\n```python\nstdout_text = stdout.decode()\n# Skip lines until we find JSON array or object\njson_start = stdout_text.find('[')\nif json_start == -1:\n    json_start = stdout_text.find('{')\nif json_start >= 0:\n    stdout_text = stdout_text[json_start:]\ndata = json.loads(stdout_text)\n```\n\n**Why:** @coderef/core CLI may output progress messages before JSON\n\n**Used By:** All handlers except diagram/tag (which return text)\n\n---\n\n#### 3.2 Async Subprocess Pattern\n\n**Purpose:** Non-blocking subprocess execution with timeout\n\n**Pattern:**\n```python\nprocess = await asyncio.create_subprocess_exec(\n    *cmd,\n    stdout=asyncio.subprocess.PIPE,\n    stderr=asyncio.subprocess.PIPE,\n    cwd=project_path  # Optional\n)\n\ntry:\n    stdout, stderr = await asyncio.wait_for(\n        process.communicate(),\n        timeout=120\n    )\nexcept asyncio.TimeoutError:\n    process.kill()\n    await process.wait()\n    return [TextContent(type=\"text\", text=\"Error: Timeout\")]\n```\n\n**Why:** Prevents event loop blocking, allows concurrent tool calls\n\n**Used By:** All 11 tool handlers\n\n---\n\n## Why: Component Design Decisions\n\n### Decision 1: Handler Functions (Not Classes)\n**Why:** Simpler, functional approach; no shared state needed\n**Benefit:** Easy to test, no side effects, clear inputs/outputs\n**Alternative Rejected:** Class-based handlers (unnecessary complexity)\n\n### Decision 2: Async/Await Throughout\n**Why:** MCP protocol is async, subprocess I/O is async\n**Benefit:** Non-blocking, supports concurrent agent requests\n**Alternative Rejected:** Threading (more complex, less Pythonic)\n\n### Decision 3: Subprocess Isolation\n**Why:** Separate Node.js CLI from Python MCP server\n**Benefit:** One CLI crash doesn't crash server, clean separation\n**Alternative Rejected:** In-process CLI (would require Node.js bridge)\n\n### Decision 4: Consistent Error Handling\n**Why:** All handlers follow same pattern (try/except, timeout, JSON parse)\n**Benefit:** Predictable behavior, easier debugging\n**Alternative Rejected:** Per-handler error handling (inconsistent UX)\n\n---\n\n## When: Adding New Components\n\n### How to Add a New Tool Handler\n\n1. **Define Tool Schema** (in `@app.list_tools()`)\n```python\nTool(\n    name=\"coderef_newtool\",\n    description=\"What this tool does\",\n    inputSchema={\n        \"type\": \"object\",\n        \"properties\": {\n            \"project_path\": {\"type\": \"string\", \"description\": \"...\"},\n            \"param1\": {\"type\": \"string\", \"description\": \"...\"}\n        },\n        \"required\": [\"project_path\"]\n    }\n)\n```\n\n2. **Add Handler Function**\n```python\nasync def handle_coderef_newtool(args: dict) -> list[TextContent]:\n    \"\"\"Handle /newtool tool - description.\"\"\"\n    project_path = args.get(\"project_path\", \".\")\n    param1 = args.get(\"param1\")\n\n    cmd = [*CLI_COMMAND, \"newtool\", project_path, \"--param1\", param1, \"--json\"]\n\n    # ... follow async subprocess pattern ...\n```\n\n3. **Register in call_tool Router**\n```python\n@app.call_tool()\nasync def call_tool(name: str, arguments: dict) -> list[TextContent]:\n    try:\n        if name == \"coderef_newtool\":\n            return await handle_coderef_newtool(arguments)\n        # ... other handlers ...\n```\n\n4. **Test with Real CLI**\n```python\n# Manual test\npython server.py\n# In another terminal:\necho '{\"tool\": \"coderef_newtool\", \"args\": {\"project_path\": \"/path/to/project\"}}' | python -m mcp.client\n```\n\n---\n\n## Examples\n\n### Example 1: Using Scan Handler\n```python\n# Agent calls scan tool\nargs = {\n    \"project_path\": \"/Users/dev/frontend-app\",\n    \"languages\": [\"ts\", \"tsx\"],\n    \"use_ast\": True\n}\n\nresponse = await handle_coderef_scan(args)\n# Returns:\n# [TextContent(type=\"text\", text='{\"success\": true, \"elements_found\": 247, ...}')]\n```\n\n---\n\n### Example 2: Using Query Handler\n```python\n# Agent calls query tool\nargs = {\n    \"project_path\": \"/Users/dev/app\",\n    \"query_type\": \"calls-me\",\n    \"target\": \"login\"\n}\n\nresponse = await handle_coderef_query(args)\n# Returns:\n# [TextContent(type=\"text\", text='{\"success\": true, \"results\": [...]}')]\n```\n\n---\n\n### Example 3: Error Handling Pattern\n```python\n# Timeout scenario\nargs = {\"project_path\": \"/very/large/project\"}\n\nresponse = await handle_coderef_scan(args)\n# After 120s:\n# [TextContent(type=\"text\", text=\"Error: Scan timeout (120s exceeded)\")]\n\n# CLI not found scenario\nresponse = await handle_coderef_scan(args)\n# [TextContent(type=\"text\", text=\"Error: [Errno 2] No such file or directory: 'coderef'\")]\n```\n\n---\n\n## State Management\n\n**Server State:** Stateless\n- No shared state between tool calls\n- Each handler is independent\n- No caching (intentional for accuracy)\n\n**CLI State:** External\n- @coderef/core CLI may maintain `.coderef-index.json` cache\n- MCP server doesn't manage this state\n- Fresh subprocess on each tool call\n\n---\n\n## References\n\n- **[API.md](API.md)** - API endpoint documentation (tool schemas)\n- **[SCHEMA.md](SCHEMA.md)** - Data schema definitions (input/output types)\n- **[ARCHITECTURE.md](ARCHITECTURE.md)** - System architecture (component interactions)\n- **[server.py](../server.py)** - Full implementation source code\n\n---\n\n## AI Agent Instructions\n\n**When extending this server:**\n1. Follow the handler pattern template exactly (async, timeout, JSON parse, error handling)\n2. Register new tools in both `list_tools()` and `call_tool()` router\n3. Test with real @coderef/core CLI before committing\n4. Document new tools in API.md and update SCHEMA.md\n\n**When debugging handlers:**\n1. Check CLI command construction first (print `cmd` variable)\n2. Run CLI command manually to verify it works standalone\n3. Check timeout duration (large projects need more time)\n4. Verify JSON parsing logic (skip progress messages correctly)\n\n**Best practices:**\n- Keep handlers pure (no side effects, no shared state)\n- Use descriptive error messages (help agents diagnose issues)\n- Always validate required parameters before subprocess execution\n- Return structured JSON (consistency across all tools)\n\n---\n\n**Generated:** 2025-12-30\n**Maintained by:** coderef-context MCP Server\n**For AI Agents:** This component reference helps you understand the modular architecture and extend the server with new code intelligence tools.\n",
      "word_count": 1993
    },
    "readme": {
      "sections": {
        "coderef-context_mcp_server": "**Project:** coderef-context\n**Version:** 1.1.0\n**Status:** \u2705 Production\n**Last Updated:** 2025-12-30\n**Maintainer:** willh, Claude Code AI\n\n**Expose @coderef/core CLI tools to Claude agents as standardized MCP tools**\n\n---",
        "purpose": "The coderef-context MCP server provides AI agents with real-time code intelligence during feature implementation. It bridges Claude agents and the @coderef/core TypeScript analysis engine, enabling agents to:\n\n- **Discover** what code elements exist before implementing new features\n- **Understand** dependencies and relationships before refactoring\n- **Assess** impact and risk before making breaking changes\n- **Estimate** effort based on complexity metrics\n- **Learn** from existing patterns to avoid reimplementation\n\n**Core Innovation:** Eliminates \"blind coding\" by giving agents full codebase context through 11 MCP tools.\n\n---",
        "overview": "### What This Server Does\n\ncoderef-context is a **Python-based MCP server** that wraps @coderef/core CLI commands and exposes them as tools for AI agents. It operates in the CodeRef ecosystem alongside:\n\n- **coderef-workflow** - Planning and orchestration\n- **coderef-docs** - Documentation generation\n- **coderef-personas** - Expert agent roles\n- **coderef-testing** - Test automation\n\n### Why It Exists\n\nAgents implementing features need code intelligence to make informed decisions:\n\n\u274c **Without coderef-context:**\n```\nAgent: \"I'll create a new ThemeProvider component\"\n(Implements duplicate component, unaware existing one exists)\n```\n\n\u2705 **With coderef-context:**\n```\nAgent: \"Let me scan the project first...\"\n(Calls coderef_scan, discovers existing ThemeProvider)\nAgent: \"ThemeProvider exists at src/theme/ThemeProvider.tsx. I'll extend it instead.\"\n```\n\n---",
        "what:_tools_exposed": "### Core Intelligence Tools\n\n**1. coderef_scan** - Discover all code elements\n- **Input:** project_path, languages, use_ast\n- **Output:** Array of functions, classes, components, hooks with locations\n- **Use Case:** Initial project understanding before implementation\n\n**2. coderef_query** - Query code relationships\n- **Input:** project_path, query_type, target, max_depth\n- **Query Types:** calls, calls-me, imports, imports-me, depends-on, depends-on-me\n- **Use Case:** Understanding what depends on what before refactoring\n\n**3. coderef_impact** - Analyze change impact\n- **Input:** project_path, element, operation (modify/delete/refactor)\n- **Output:** Affected files, risk level (LOW/MEDIUM/HIGH), ripple effects\n- **Use Case:** Pre-refactoring risk assessment\n\n**4. coderef_complexity** - Get complexity metrics\n- **Input:** project_path, element\n- **Output:** LOC, cyclomatic complexity, dependencies, test coverage %\n- **Use Case:** Effort estimation for implementation\n\n**5. coderef_patterns** - Discover code patterns\n- **Input:** project_path, pattern_type, limit\n- **Output:** Common patterns (React Query, Redux, etc.), usage counts\n- **Use Case:** Learning existing conventions before implementing\n\n### Supporting Tools\n\n**6. coderef_coverage** - Test coverage analysis\n**7. coderef_context** - Comprehensive codebase context (markdown + JSON)\n**8. coderef_validate** - Validate CodeRef2 references\n**9. coderef_drift** - Detect drift between index and code\n**10. coderef_diagram** - Generate dependency diagrams (Mermaid/Graphviz)\n**11. coderef_tag** - Add CodeRef2 tags to source files\n\n---",
        "why:_use_cases": "### Use Case 1: Safe Refactoring (Impact Analysis)\n\n**Scenario:** Agent needs to refactor AuthService\n\n```python",
        "step_1:_check_impact": "result = await call_tool(\"coderef_impact\", {\n    \"project_path\": \"/path/to/app\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n})",
        "result:": "{\n  \"results\": [\n    {\"from\": \"CheckoutComponent\", \"to\": \"PaymentGateway\", \"type\": \"import\"},\n    {\"from\": \"CheckoutComponent\", \"to\": \"OrderService\", \"type\": \"import\"}\n  ]\n}",
        "decision:_12_files_affected,_medium_risk_\u2192_create_comprehensive_plan_first": "```\n\n### Use Case 2: Avoiding Duplication (Scan)\n\n**Scenario:** Agent implementing dark mode toggle\n\n```python",
        "step_1:_scan_for_existing_theme_code": "result = await call_tool(\"coderef_scan\", {\n    \"project_path\": \"/path/to/frontend\",\n    \"languages\": [\"ts\", \"tsx\"],\n    \"use_ast\": true\n})",
        "result_finds:": "- ThemeProvider (src/theme/ThemeProvider.tsx)\n- useTheme hook (src/theme/useTheme.ts)\n- ThemeContext (src/theme/context.ts)",
        "decision:_extend_existing_themeprovider_instead_of_building_new_system": "```\n\n### Use Case 3: Understanding Dependencies (Query)\n\n**Scenario:** Agent adding authentication to checkout flow\n\n```python",
        "step_1:_what_does_checkout_depend_on?": "result = await call_tool(\"coderef_query\", {\n    \"project_path\": \"/path/to/app\",\n    \"query_type\": \"imports\",\n    \"target\": \"CheckoutComponent\"\n})",
        "decision:_add_auth_check_at_paymentgateway_entry_point": "```\n\n---",
        "when:_integration_points": "### With coderef-workflow (Planning)\n\nDuring planning phase (section 0: PREPARATION), coderef-workflow calls:\n- `coderef_scan` \u2192 Discover existing architecture\n- `coderef_query` \u2192 Understand dependencies\n- `coderef_impact` \u2192 Assess refactoring risk\n\nResult: plan.json sections populated with real code intelligence\n\n### With coderef-personas (Execution)\n\nAgents (Ava, Marcus, Quinn) call tools during task execution:\n- Before implementing \u2192 `coderef_scan` (what exists?)\n- Before refactoring \u2192 `coderef_impact` (what breaks?)\n- Before choosing approach \u2192 `coderef_patterns` (what patterns exist?)\n\nResult: Informed decisions based on actual codebase\n\n### With coderef-docs (Documentation)\n\nWhen generating foundation docs, coderef-docs calls:\n- `coderef_scan` \u2192 Extract API endpoints, schemas, components\n- Populates API.md, SCHEMA.md, COMPONENTS.md with real data\n\nResult: Documentation reflects actual code (not placeholders)\n\n---",
        "examples": "### Example 1: Complete Agent Workflow\n\n```python",
        "agent_task:_\"implement_user_profile_feature\"": "",
        "step_1:_understand_existing_code": "scan_result = await call_tool(\"coderef_scan\", {\n    \"project_path\": \"/Users/dev/app\",\n    \"use_ast\": true\n})",
        "\u2192_247_elements_found_(finds_existing_userservice,_profilecomponent)": "",
        "step_2:_check_existing_profile_implementation": "query_result = await call_tool(\"coderef_query\", {\n    \"query_type\": \"imports\",\n    \"target\": \"ProfileComponent\"\n})",
        "\u2192_profilecomponent_imports_userservice_(pattern_discovered)": "",
        "step_3:_estimate_effort": "complexity_result = await call_tool(\"coderef_complexity\", {\n    \"element\": \"UserService\"\n})",
        "\u2192_145_loc,_complexity=8,_60%_tested": "",
        "decision:_extend_profilecomponent,_improve_userservice_tests": "```\n\n---",
        "prerequisites": "### Required\n\n1. **Python 3.11+** (async/await support)\n2. **@coderef/core CLI** installed (TypeScript analysis engine)\n   - Global install: `npm install -g @coderef/core`\n   - Or local: Set `CODEREF_CLI_PATH` environment variable\n\n### Optional\n\n- **Git repository** (for drift detection, DELIVERABLES tracking)\n- **Test coverage data** (for coverage analysis)\n\n---",
        "installation": "### Step 1: Install Python Package\n\n```bash\ncd C:\\Users\\willh\\.mcp-servers\\coderef-context\npip install -e .\n```\n\n### Step 2: Configure CLI Path\n\nSet environment variable (if @coderef/core not globally installed):\n\n```bash\nexport CODEREF_CLI_PATH=\"/path/to/coderef-system/packages/cli\"\n```\n\n**Default Path (Windows):**\n```\nC:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli\n```\n\n### Step 3: Register in .mcp.json\n\nAdd to `~/.mcp.json`:\n\n```json\n{\n  \"mcpServers\": {\n    \"coderef-context\": {\n      \"command\": \"python\",\n      \"args\": [\"C:/Users/willh/.mcp-servers/coderef-context/server.py\"],\n      \"cwd\": \"C:/Users/willh/.mcp-servers/coderef-context\",\n      \"env\": {\n        \"CODEREF_CLI_PATH\": \"C:/Users/willh/Desktop/projects/coderef-system/packages/cli\"\n      },\n      \"description\": \"MCP server exposing @coderef/core CLI tools to Claude agents\",\n      \"tools\": [\n        \"coderef_scan\", \"coderef_query\", \"coderef_impact\",\n        \"coderef_complexity\", \"coderef_patterns\", \"coderef_coverage\",\n        \"coderef_context\", \"coderef_validate\", \"coderef_drift\",\n        \"coderef_diagram\", \"coderef_tag\"\n      ]\n    }\n  }\n}\n```\n\n### Step 4: Restart Claude Code\n\n- Close Claude Code completely\n- Reopen Claude Code\n- Verify tools appear in autocomplete\n\n---",
        "quick_start": "### Test the Server\n\n```bash",
        "start_server": "python server.py",
        "in_another_terminal,_test_a_tool": "echo '{\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/project\"}}' | python -m mcp.client\n```\n\n### Agent Usage\n\nAgents can call tools directly:\n\n```python",
        "discover_code_elements": "result = await call_tool(\"coderef_context\", \"coderef_scan\", {\n    \"project_path\": \"/path/to/project\",\n    \"use_ast\": true\n})",
        "query_dependencies": "result = await call_tool(\"coderef_context\", \"coderef_query\", {\n    \"project_path\": \"/path/to/project\",\n    \"query_type\": \"calls-me\",\n    \"target\": \"login\"\n})",
        "analyze_impact": "result = await call_tool(\"coderef_context\", \"coderef_impact\", {\n    \"project_path\": \"/path/to/project\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n})\n```\n\n---",
        "troubleshooting": "### Error: CLI path not found\n\n**Symptom:**\n```\nError: [Errno 2] No such file or directory: 'coderef'\n```\n\n**Solution:**\n```bash",
        "option_1:_install_globally": "npm install -g @coderef/core",
        "option_2:_set_environment_variable": "export CODEREF_CLI_PATH=\"/path/to/coderef-system/packages/cli\"",
        "verify_cli_works": "coderef --version",
        "or": "node /path/to/cli/dist/cli.js --version\n```\n\n---\n\n### Error: Scan timeout (120s exceeded)\n\n**Symptom:**\n```\nError: Scan timeout (120s exceeded)\n```\n\n**Cause:** Project is very large (>500k LOC)\n\n**Solutions:**\n1. Use smaller scope (scan specific directories)\n2. Disable AST analysis (use_ast=false) for faster scan\n3. Increase timeout in server.py (advanced)\n\n---\n\n### Error: Tool not found\n\n**Symptom:**\n```\nTool 'coderef_scan' not found in autocomplete\n```\n\n**Solutions:**\n1. Check `.mcp.json` registration\n2. Restart Claude Code\n3. Clear MCP cache:\n```bash\nrm \"C:\\Users\\willh\\.cursor\\projects\\{PROJECT_ID}\\mcp-cache.json\"\n```\n4. Verify server starts without errors:\n```bash\npython server.py\n```\n\n---\n\n### Error: JSON parse error\n\n**Symptom:**\n```\nJSON parse error: Unexpected token\n```\n\n**Cause:** CLI output contains progress messages before JSON\n\n**Solution:** This is handled automatically in server.py (skips to JSON start). If persists:\n1. Check CLI version compatibility\n2. Verify CLI works standalone:\n```bash\ncoderef scan /path/to/project --json\n```\n\n---",
        "configuration": "### Environment Variables\n\n**CODEREF_CLI_PATH:**\n- Purpose: Override default CLI path\n- Default: `C:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli`\n- Usage: Set in `.mcp.json` env section\n\n### CLI Detection Logic\n\nThe server automatically detects CLI path in this order:\n\n1. **Global install** (`where coderef` on Windows, `which coderef` on Unix)\n2. **Test global** (`coderef --version`)\n3. **Local path** (`$CODEREF_CLI_PATH/dist/cli.js`)\n4. **Fallback** (try `coderef` command, may fail)\n\n---",
        "file_structure": "```\ncoderef-context/\n\u251c\u2500\u2500 server.py                    # MCP server entry point (1073 lines)\n\u251c\u2500\u2500 pyproject.toml               # Python package metadata\n\u251c\u2500\u2500 README.md                    # This file (user-facing overview)\n\u251c\u2500\u2500 CLAUDE.md                    # AI context documentation\n\u251c\u2500\u2500 coderef/\n\u2502   \u2514\u2500\u2500 foundation-docs/\n\u2502       \u251c\u2500\u2500 API.md               # API endpoint reference\n\u2502       \u251c\u2500\u2500 SCHEMA.md            # Data schema definitions\n\u2502       \u251c\u2500\u2500 COMPONENTS.md        # Component architecture\n\u2502       \u2514\u2500\u2500 ARCHITECTURE.md      # System architecture\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_server.py           # Unit tests (future)\n```\n\n---",
        "architecture": "### High-Level Data Flow\n\n```\nAI Agent (Claude)\n    \u2193 MCP Protocol (JSON-RPC 2.0 over stdio)\nPython MCP Server (coderef-context)\n    \u2193 Async subprocess execution\n@coderef/core CLI (Node.js)\n    \u2193 File I/O + AST parsing\nProject Codebase (TypeScript, JavaScript, React, etc.)\n```\n\n### Tool Handler Pattern\n\nAll 11 tools follow this async pattern:\n\n1. **Validate** input arguments\n2. **Build** CLI command (`coderef <command> <args> --json`)\n3. **Execute** async subprocess (timeout: 120s)\n4. **Parse** JSON output (skip CLI progress messages)\n5. **Return** structured response (`{success: true, ...}`)\n6. **Handle** errors (timeout, CLI crash, JSON parse)\n\n---",
        "performance": "### Typical Response Times\n\n- `coderef_scan`: 5-15s (50k LOC, AST mode)\n- `coderef_query`: 1-3s (dependency lookup)\n- `coderef_impact`: 2-5s (impact analysis)\n- `coderef_complexity`: 10-30s (full context)\n- Other tools: <5s\n\n### Scalability\n\n- \u2705 Concurrent requests supported (async subprocess)\n- \u2705 100k LOC projects complete within 120s timeout\n- \u274c 500k LOC projects may timeout (use smaller scope)\n\n---",
        "development": "### Running Tests\n\n```bash\npytest tests/ -v\n```\n\n### Adding New Tools\n\n1. Define tool schema in `@app.list_tools()`\n2. Implement handler function (follow pattern)\n3. Add route in `@app.call_tool()`\n4. Update API.md, SCHEMA.md, COMPONENTS.md\n\nSee [COMPONENTS.md](coderef/foundation-docs/COMPONENTS.md) for detailed pattern.\n\n---",
        "status_&_roadmap": "### Current Version: 1.1.0 (Production)\n\n**Implemented:**\n- \u2705 11 MCP tools (scan, query, impact, complexity, patterns, coverage, context, validate, drift, diagram, tag)\n- \u2705 Async subprocess architecture\n- \u2705 Smart CLI path detection\n- \u2705 Error handling & timeouts\n- \u2705 JSON parsing with progress message skipping\n- \u2705 Integration with coderef-workflow, coderef-personas, coderef-docs\n\n**Limitations:**\n- No caching (intentional for accuracy)\n- 120s timeout (may need tuning for large projects)\n- No result streaming (entire output returned at once)\n\n### Future (v2.0)\n\n- \u23f3 Optional LRU cache with TTL\n- \u23f3 Streaming support for large results\n- \u23f3 Parallel analysis for multi-module projects\n- \u23f3 Performance metrics & monitoring\n- \u23f3 Health check endpoint\n\n---",
        "related_documentation": "- **[API.md](coderef/foundation-docs/API.md)** - API endpoint reference with examples\n- **[SCHEMA.md](coderef/foundation-docs/SCHEMA.md)** - Data schema definitions (input/output types)\n- **[COMPONENTS.md](coderef/foundation-docs/COMPONENTS.md)** - Component architecture (handlers, patterns)\n- **[ARCHITECTURE.md](coderef/foundation-docs/ARCHITECTURE.md)** - System architecture & design decisions\n- **[CLAUDE.md](CLAUDE.md)** - AI context documentation (747 lines)\n\n### Related Projects\n\n- **[@coderef/core](https://github.com/coderef-system)** - TypeScript analysis engine\n- **coderef-workflow** - Planning and orchestration MCP server\n- **coderef-docs** - Documentation generation MCP server\n- **coderef-personas** - Expert agent roles MCP server\n- **coderef-testing** - Test automation MCP server\n\n---",
        "support": "**Issues:** Report at https://github.com/anthropics/claude-code/issues\n**Maintainer:** willh, Claude Code AI\n**Status:** \u2705 Production Ready\n\n---",
        "ai_agent_instructions": "**When using this server:**\n\n1. **Discovery First** - Always call `coderef_scan` before implementing to understand what exists\n2. **Dependency Awareness** - Use `coderef_query` to trace relationships before refactoring\n3. **Risk Assessment** - Call `coderef_impact` to evaluate change risk before making breaking changes\n4. **Pattern Learning** - Check `coderef_patterns` to discover existing conventions\n5. **Effort Estimation** - Use `coderef_complexity` to estimate implementation time\n\n**Error handling:**\n- Retry once on timeout (may be temporary)\n- If CLI not found, ask user to configure CODEREF_CLI_PATH\n- Parse JSON carefully (skip CLI progress messages)\n\n**Best practices:**\n- Use AST analysis (use_ast=true) for 99% accuracy\n- Set appropriate max_depth (3 is usually sufficient)\n- Combine tools: scan \u2192 query \u2192 impact for comprehensive understanding\n\n---\n\n**Generated:** 2025-12-30\n**Version:** 1.1.0\n**Status:** \u2705 Production\n**For AI Agents:** This server provides code intelligence to eliminate blind coding. Use it proactively during all implementation tasks."
      },
      "full_content": "# coderef-context MCP Server\n\n**Project:** coderef-context\n**Version:** 1.1.0\n**Status:** \u2705 Production\n**Last Updated:** 2025-12-30\n**Maintainer:** willh, Claude Code AI\n\n**Expose @coderef/core CLI tools to Claude agents as standardized MCP tools**\n\n---\n\n## Purpose\n\nThe coderef-context MCP server provides AI agents with real-time code intelligence during feature implementation. It bridges Claude agents and the @coderef/core TypeScript analysis engine, enabling agents to:\n\n- **Discover** what code elements exist before implementing new features\n- **Understand** dependencies and relationships before refactoring\n- **Assess** impact and risk before making breaking changes\n- **Estimate** effort based on complexity metrics\n- **Learn** from existing patterns to avoid reimplementation\n\n**Core Innovation:** Eliminates \"blind coding\" by giving agents full codebase context through 11 MCP tools.\n\n---\n\n## Overview\n\n### What This Server Does\n\ncoderef-context is a **Python-based MCP server** that wraps @coderef/core CLI commands and exposes them as tools for AI agents. It operates in the CodeRef ecosystem alongside:\n\n- **coderef-workflow** - Planning and orchestration\n- **coderef-docs** - Documentation generation\n- **coderef-personas** - Expert agent roles\n- **coderef-testing** - Test automation\n\n### Why It Exists\n\nAgents implementing features need code intelligence to make informed decisions:\n\n\u274c **Without coderef-context:**\n```\nAgent: \"I'll create a new ThemeProvider component\"\n(Implements duplicate component, unaware existing one exists)\n```\n\n\u2705 **With coderef-context:**\n```\nAgent: \"Let me scan the project first...\"\n(Calls coderef_scan, discovers existing ThemeProvider)\nAgent: \"ThemeProvider exists at src/theme/ThemeProvider.tsx. I'll extend it instead.\"\n```\n\n---\n\n## What: Tools Exposed\n\n### Core Intelligence Tools\n\n**1. coderef_scan** - Discover all code elements\n- **Input:** project_path, languages, use_ast\n- **Output:** Array of functions, classes, components, hooks with locations\n- **Use Case:** Initial project understanding before implementation\n\n**2. coderef_query** - Query code relationships\n- **Input:** project_path, query_type, target, max_depth\n- **Query Types:** calls, calls-me, imports, imports-me, depends-on, depends-on-me\n- **Use Case:** Understanding what depends on what before refactoring\n\n**3. coderef_impact** - Analyze change impact\n- **Input:** project_path, element, operation (modify/delete/refactor)\n- **Output:** Affected files, risk level (LOW/MEDIUM/HIGH), ripple effects\n- **Use Case:** Pre-refactoring risk assessment\n\n**4. coderef_complexity** - Get complexity metrics\n- **Input:** project_path, element\n- **Output:** LOC, cyclomatic complexity, dependencies, test coverage %\n- **Use Case:** Effort estimation for implementation\n\n**5. coderef_patterns** - Discover code patterns\n- **Input:** project_path, pattern_type, limit\n- **Output:** Common patterns (React Query, Redux, etc.), usage counts\n- **Use Case:** Learning existing conventions before implementing\n\n### Supporting Tools\n\n**6. coderef_coverage** - Test coverage analysis\n**7. coderef_context** - Comprehensive codebase context (markdown + JSON)\n**8. coderef_validate** - Validate CodeRef2 references\n**9. coderef_drift** - Detect drift between index and code\n**10. coderef_diagram** - Generate dependency diagrams (Mermaid/Graphviz)\n**11. coderef_tag** - Add CodeRef2 tags to source files\n\n---\n\n## Why: Use Cases\n\n### Use Case 1: Safe Refactoring (Impact Analysis)\n\n**Scenario:** Agent needs to refactor AuthService\n\n```python\n# Step 1: Check impact\nresult = await call_tool(\"coderef_impact\", {\n    \"project_path\": \"/path/to/app\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n})\n\n# Result:\n{\n  \"affected_files\": 12,\n  \"risk_level\": \"MEDIUM\",\n  \"ripple_effects\": [\n    {\"file\": \"src/login/Login.tsx\", \"impact\": \"direct call\"},\n    {\"file\": \"src/profile/Profile.tsx\", \"impact\": \"direct call\"}\n  ]\n}\n\n# Decision: 12 files affected, MEDIUM risk \u2192 Create comprehensive plan first\n```\n\n### Use Case 2: Avoiding Duplication (Scan)\n\n**Scenario:** Agent implementing dark mode toggle\n\n```python\n# Step 1: Scan for existing theme code\nresult = await call_tool(\"coderef_scan\", {\n    \"project_path\": \"/path/to/frontend\",\n    \"languages\": [\"ts\", \"tsx\"],\n    \"use_ast\": true\n})\n\n# Result finds:\n- ThemeProvider (src/theme/ThemeProvider.tsx)\n- useTheme hook (src/theme/useTheme.ts)\n- ThemeContext (src/theme/context.ts)\n\n# Decision: Extend existing ThemeProvider instead of building new system\n```\n\n### Use Case 3: Understanding Dependencies (Query)\n\n**Scenario:** Agent adding authentication to checkout flow\n\n```python\n# Step 1: What does checkout depend on?\nresult = await call_tool(\"coderef_query\", {\n    \"project_path\": \"/path/to/app\",\n    \"query_type\": \"imports\",\n    \"target\": \"CheckoutComponent\"\n})\n\n# Result:\n{\n  \"results\": [\n    {\"from\": \"CheckoutComponent\", \"to\": \"PaymentGateway\", \"type\": \"import\"},\n    {\"from\": \"CheckoutComponent\", \"to\": \"OrderService\", \"type\": \"import\"}\n  ]\n}\n\n# Decision: Add auth check at PaymentGateway entry point\n```\n\n---\n\n## When: Integration Points\n\n### With coderef-workflow (Planning)\n\nDuring planning phase (section 0: PREPARATION), coderef-workflow calls:\n- `coderef_scan` \u2192 Discover existing architecture\n- `coderef_query` \u2192 Understand dependencies\n- `coderef_impact` \u2192 Assess refactoring risk\n\nResult: plan.json sections populated with real code intelligence\n\n### With coderef-personas (Execution)\n\nAgents (Ava, Marcus, Quinn) call tools during task execution:\n- Before implementing \u2192 `coderef_scan` (what exists?)\n- Before refactoring \u2192 `coderef_impact` (what breaks?)\n- Before choosing approach \u2192 `coderef_patterns` (what patterns exist?)\n\nResult: Informed decisions based on actual codebase\n\n### With coderef-docs (Documentation)\n\nWhen generating foundation docs, coderef-docs calls:\n- `coderef_scan` \u2192 Extract API endpoints, schemas, components\n- Populates API.md, SCHEMA.md, COMPONENTS.md with real data\n\nResult: Documentation reflects actual code (not placeholders)\n\n---\n\n## Examples\n\n### Example 1: Complete Agent Workflow\n\n```python\n# Agent task: \"Implement user profile feature\"\n\n# Step 1: Understand existing code\nscan_result = await call_tool(\"coderef_scan\", {\n    \"project_path\": \"/Users/dev/app\",\n    \"use_ast\": true\n})\n# \u2192 247 elements found (finds existing UserService, ProfileComponent)\n\n# Step 2: Check existing profile implementation\nquery_result = await call_tool(\"coderef_query\", {\n    \"query_type\": \"imports\",\n    \"target\": \"ProfileComponent\"\n})\n# \u2192 ProfileComponent imports UserService (pattern discovered)\n\n# Step 3: Estimate effort\ncomplexity_result = await call_tool(\"coderef_complexity\", {\n    \"element\": \"UserService\"\n})\n# \u2192 145 LOC, complexity=8, 60% tested\n\n# Step 4: Implement with full context\n# Agent now knows:\n# - ProfileComponent exists but is incomplete\n# - UserService exists with moderate complexity\n# - Need to add tests (only 60% coverage)\n# Decision: Extend ProfileComponent, improve UserService tests\n```\n\n---\n\n## Prerequisites\n\n### Required\n\n1. **Python 3.11+** (async/await support)\n2. **@coderef/core CLI** installed (TypeScript analysis engine)\n   - Global install: `npm install -g @coderef/core`\n   - Or local: Set `CODEREF_CLI_PATH` environment variable\n\n### Optional\n\n- **Git repository** (for drift detection, DELIVERABLES tracking)\n- **Test coverage data** (for coverage analysis)\n\n---\n\n## Installation\n\n### Step 1: Install Python Package\n\n```bash\ncd C:\\Users\\willh\\.mcp-servers\\coderef-context\npip install -e .\n```\n\n### Step 2: Configure CLI Path\n\nSet environment variable (if @coderef/core not globally installed):\n\n```bash\nexport CODEREF_CLI_PATH=\"/path/to/coderef-system/packages/cli\"\n```\n\n**Default Path (Windows):**\n```\nC:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli\n```\n\n### Step 3: Register in .mcp.json\n\nAdd to `~/.mcp.json`:\n\n```json\n{\n  \"mcpServers\": {\n    \"coderef-context\": {\n      \"command\": \"python\",\n      \"args\": [\"C:/Users/willh/.mcp-servers/coderef-context/server.py\"],\n      \"cwd\": \"C:/Users/willh/.mcp-servers/coderef-context\",\n      \"env\": {\n        \"CODEREF_CLI_PATH\": \"C:/Users/willh/Desktop/projects/coderef-system/packages/cli\"\n      },\n      \"description\": \"MCP server exposing @coderef/core CLI tools to Claude agents\",\n      \"tools\": [\n        \"coderef_scan\", \"coderef_query\", \"coderef_impact\",\n        \"coderef_complexity\", \"coderef_patterns\", \"coderef_coverage\",\n        \"coderef_context\", \"coderef_validate\", \"coderef_drift\",\n        \"coderef_diagram\", \"coderef_tag\"\n      ]\n    }\n  }\n}\n```\n\n### Step 4: Restart Claude Code\n\n- Close Claude Code completely\n- Reopen Claude Code\n- Verify tools appear in autocomplete\n\n---\n\n## Quick Start\n\n### Test the Server\n\n```bash\n# Start server\npython server.py\n\n# In another terminal, test a tool\necho '{\"tool\": \"coderef_scan\", \"args\": {\"project_path\": \"/path/to/project\"}}' | python -m mcp.client\n```\n\n### Agent Usage\n\nAgents can call tools directly:\n\n```python\n# Discover code elements\nresult = await call_tool(\"coderef_context\", \"coderef_scan\", {\n    \"project_path\": \"/path/to/project\",\n    \"use_ast\": true\n})\n\n# Query dependencies\nresult = await call_tool(\"coderef_context\", \"coderef_query\", {\n    \"project_path\": \"/path/to/project\",\n    \"query_type\": \"calls-me\",\n    \"target\": \"login\"\n})\n\n# Analyze impact\nresult = await call_tool(\"coderef_context\", \"coderef_impact\", {\n    \"project_path\": \"/path/to/project\",\n    \"element\": \"AuthService\",\n    \"operation\": \"refactor\"\n})\n```\n\n---\n\n## Troubleshooting\n\n### Error: CLI path not found\n\n**Symptom:**\n```\nError: [Errno 2] No such file or directory: 'coderef'\n```\n\n**Solution:**\n```bash\n# Option 1: Install globally\nnpm install -g @coderef/core\n\n# Option 2: Set environment variable\nexport CODEREF_CLI_PATH=\"/path/to/coderef-system/packages/cli\"\n\n# Verify CLI works\ncoderef --version\n# or\nnode /path/to/cli/dist/cli.js --version\n```\n\n---\n\n### Error: Scan timeout (120s exceeded)\n\n**Symptom:**\n```\nError: Scan timeout (120s exceeded)\n```\n\n**Cause:** Project is very large (>500k LOC)\n\n**Solutions:**\n1. Use smaller scope (scan specific directories)\n2. Disable AST analysis (use_ast=false) for faster scan\n3. Increase timeout in server.py (advanced)\n\n---\n\n### Error: Tool not found\n\n**Symptom:**\n```\nTool 'coderef_scan' not found in autocomplete\n```\n\n**Solutions:**\n1. Check `.mcp.json` registration\n2. Restart Claude Code\n3. Clear MCP cache:\n```bash\nrm \"C:\\Users\\willh\\.cursor\\projects\\{PROJECT_ID}\\mcp-cache.json\"\n```\n4. Verify server starts without errors:\n```bash\npython server.py\n```\n\n---\n\n### Error: JSON parse error\n\n**Symptom:**\n```\nJSON parse error: Unexpected token\n```\n\n**Cause:** CLI output contains progress messages before JSON\n\n**Solution:** This is handled automatically in server.py (skips to JSON start). If persists:\n1. Check CLI version compatibility\n2. Verify CLI works standalone:\n```bash\ncoderef scan /path/to/project --json\n```\n\n---\n\n## Configuration\n\n### Environment Variables\n\n**CODEREF_CLI_PATH:**\n- Purpose: Override default CLI path\n- Default: `C:\\Users\\willh\\Desktop\\projects\\coderef-system\\packages\\cli`\n- Usage: Set in `.mcp.json` env section\n\n### CLI Detection Logic\n\nThe server automatically detects CLI path in this order:\n\n1. **Global install** (`where coderef` on Windows, `which coderef` on Unix)\n2. **Test global** (`coderef --version`)\n3. **Local path** (`$CODEREF_CLI_PATH/dist/cli.js`)\n4. **Fallback** (try `coderef` command, may fail)\n\n---\n\n## File Structure\n\n```\ncoderef-context/\n\u251c\u2500\u2500 server.py                    # MCP server entry point (1073 lines)\n\u251c\u2500\u2500 pyproject.toml               # Python package metadata\n\u251c\u2500\u2500 README.md                    # This file (user-facing overview)\n\u251c\u2500\u2500 CLAUDE.md                    # AI context documentation\n\u251c\u2500\u2500 coderef/\n\u2502   \u2514\u2500\u2500 foundation-docs/\n\u2502       \u251c\u2500\u2500 API.md               # API endpoint reference\n\u2502       \u251c\u2500\u2500 SCHEMA.md            # Data schema definitions\n\u2502       \u251c\u2500\u2500 COMPONENTS.md        # Component architecture\n\u2502       \u2514\u2500\u2500 ARCHITECTURE.md      # System architecture\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 test_server.py           # Unit tests (future)\n```\n\n---\n\n## Architecture\n\n### High-Level Data Flow\n\n```\nAI Agent (Claude)\n    \u2193 MCP Protocol (JSON-RPC 2.0 over stdio)\nPython MCP Server (coderef-context)\n    \u2193 Async subprocess execution\n@coderef/core CLI (Node.js)\n    \u2193 File I/O + AST parsing\nProject Codebase (TypeScript, JavaScript, React, etc.)\n```\n\n### Tool Handler Pattern\n\nAll 11 tools follow this async pattern:\n\n1. **Validate** input arguments\n2. **Build** CLI command (`coderef <command> <args> --json`)\n3. **Execute** async subprocess (timeout: 120s)\n4. **Parse** JSON output (skip CLI progress messages)\n5. **Return** structured response (`{success: true, ...}`)\n6. **Handle** errors (timeout, CLI crash, JSON parse)\n\n---\n\n## Performance\n\n### Typical Response Times\n\n- `coderef_scan`: 5-15s (50k LOC, AST mode)\n- `coderef_query`: 1-3s (dependency lookup)\n- `coderef_impact`: 2-5s (impact analysis)\n- `coderef_complexity`: 10-30s (full context)\n- Other tools: <5s\n\n### Scalability\n\n- \u2705 Concurrent requests supported (async subprocess)\n- \u2705 100k LOC projects complete within 120s timeout\n- \u274c 500k LOC projects may timeout (use smaller scope)\n\n---\n\n## Development\n\n### Running Tests\n\n```bash\npytest tests/ -v\n```\n\n### Adding New Tools\n\n1. Define tool schema in `@app.list_tools()`\n2. Implement handler function (follow pattern)\n3. Add route in `@app.call_tool()`\n4. Update API.md, SCHEMA.md, COMPONENTS.md\n\nSee [COMPONENTS.md](coderef/foundation-docs/COMPONENTS.md) for detailed pattern.\n\n---\n\n## Status & Roadmap\n\n### Current Version: 1.1.0 (Production)\n\n**Implemented:**\n- \u2705 11 MCP tools (scan, query, impact, complexity, patterns, coverage, context, validate, drift, diagram, tag)\n- \u2705 Async subprocess architecture\n- \u2705 Smart CLI path detection\n- \u2705 Error handling & timeouts\n- \u2705 JSON parsing with progress message skipping\n- \u2705 Integration with coderef-workflow, coderef-personas, coderef-docs\n\n**Limitations:**\n- No caching (intentional for accuracy)\n- 120s timeout (may need tuning for large projects)\n- No result streaming (entire output returned at once)\n\n### Future (v2.0)\n\n- \u23f3 Optional LRU cache with TTL\n- \u23f3 Streaming support for large results\n- \u23f3 Parallel analysis for multi-module projects\n- \u23f3 Performance metrics & monitoring\n- \u23f3 Health check endpoint\n\n---\n\n## Related Documentation\n\n- **[API.md](coderef/foundation-docs/API.md)** - API endpoint reference with examples\n- **[SCHEMA.md](coderef/foundation-docs/SCHEMA.md)** - Data schema definitions (input/output types)\n- **[COMPONENTS.md](coderef/foundation-docs/COMPONENTS.md)** - Component architecture (handlers, patterns)\n- **[ARCHITECTURE.md](coderef/foundation-docs/ARCHITECTURE.md)** - System architecture & design decisions\n- **[CLAUDE.md](CLAUDE.md)** - AI context documentation (747 lines)\n\n### Related Projects\n\n- **[@coderef/core](https://github.com/coderef-system)** - TypeScript analysis engine\n- **coderef-workflow** - Planning and orchestration MCP server\n- **coderef-docs** - Documentation generation MCP server\n- **coderef-personas** - Expert agent roles MCP server\n- **coderef-testing** - Test automation MCP server\n\n---\n\n## Support\n\n**Issues:** Report at https://github.com/anthropics/claude-code/issues\n**Maintainer:** willh, Claude Code AI\n**Status:** \u2705 Production Ready\n\n---\n\n## AI Agent Instructions\n\n**When using this server:**\n\n1. **Discovery First** - Always call `coderef_scan` before implementing to understand what exists\n2. **Dependency Awareness** - Use `coderef_query` to trace relationships before refactoring\n3. **Risk Assessment** - Call `coderef_impact` to evaluate change risk before making breaking changes\n4. **Pattern Learning** - Check `coderef_patterns` to discover existing conventions\n5. **Effort Estimation** - Use `coderef_complexity` to estimate implementation time\n\n**Error handling:**\n- Retry once on timeout (may be temporary)\n- If CLI not found, ask user to configure CODEREF_CLI_PATH\n- Parse JSON carefully (skip CLI progress messages)\n\n**Best practices:**\n- Use AST analysis (use_ast=true) for 99% accuracy\n- Set appropriate max_depth (3 is usually sufficient)\n- Combine tools: scan \u2192 query \u2192 impact for comprehensive understanding\n\n---\n\n**Generated:** 2025-12-30\n**Version:** 1.1.0\n**Status:** \u2705 Production\n**For AI Agents:** This server provides code intelligence to eliminate blind coding. Use it proactively during all implementation tasks.\n",
      "word_count": 2016
    }
  },
  "coderef": {
    "available": false,
    "element_count": 0,
    "has_graph": false,
    "auto_scan_attempted": true,
    "auto_scan_performed": false,
    "auto_scan_success": true
  },
  "_metadata": {
    "generated_at": "2025-12-31T16:39:44.625272",
    "generator": "coderef_foundation_generator",
    "version": "2.0.0"
  }
}