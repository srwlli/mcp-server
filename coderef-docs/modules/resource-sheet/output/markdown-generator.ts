/**
 * Markdown Generator - Writes composed documentation to markdown file
 *
 * WO-RESOURCE-SHEET-MCP-TOOL-001/OUTPUT-001
 *
 * Takes composed documentation and writes it to a properly formatted markdown file.
 */

import * as fs from 'fs';
import * as path from 'path';
import { ComposedDocumentation } from '../types';

/**
 * Generate markdown file from composed documentation
 */
export async function generateMarkdown(
  documentation: ComposedDocumentation,
  outputPath: string
): Promise<string> {
  const filePath = resolveOutputPath(outputPath, documentation.elementName, 'md');

  // Ensure output directory exists
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Write markdown file
  fs.writeFileSync(filePath, documentation.markdown, 'utf-8');

  return filePath;
}

/**
 * Resolve output path for generated file
 */
function resolveOutputPath(
  outputPath: string,
  elementName: string,
  extension: string
): string {
  // If outputPath is a directory, generate filename
  if (outputPath.endsWith('/') || fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory()) {
    const fileName = `${toKebabCase(elementName)}.${extension}`;
    return path.join(outputPath, fileName);
  }

  // If outputPath has extension, use as-is
  if (outputPath.endsWith(`.${extension}`)) {
    return outputPath;
  }

  // Otherwise, append extension
  return `${outputPath}.${extension}`;
}

/**
 * Convert element name to kebab-case for file names
 */
function toKebabCase(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2') // camelCase to kebab-case
    .replace(/[\s_]+/g, '-') // spaces/underscores to hyphens
    .toLowerCase();
}

/**
 * Preview markdown (for testing without writing files)
 */
export function previewMarkdown(documentation: ComposedDocumentation): string {
  return documentation.markdown;
}

/**
 * Validate markdown format
 */
export function validateMarkdown(markdown: string): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Check for required sections
  if (!markdown.includes('# ')) {
    errors.push('Missing top-level heading');
  }

  if (!markdown.includes('## Executive Summary')) {
    warnings.push('Missing Executive Summary section');
  }

  // Check for UDS metadata
  if (!markdown.includes('**Generated by:**')) {
    warnings.push('Missing UDS metadata (Generated by)');
  }

  if (!markdown.includes('**Timestamp:**')) {
    warnings.push('Missing UDS metadata (Timestamp)');
  }

  // Check for manual sections
  const manualCount = (markdown.match(/⚠️ \*\*MANUAL:\*\*/g) || []).length;
  if (manualCount > 0) {
    warnings.push(`${manualCount} sections require manual input`);
  }

  // Check for code blocks (should have proper formatting)
  const codeBlockMatches = markdown.match(/```/g);
  if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
    errors.push('Unclosed code block detected');
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}
