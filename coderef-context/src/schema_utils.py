"""
Schema version detection and normalization utilities.

Supports v2.0.0 (production standard, generated by coderef-dashboard) and v1.0.0
(legacy format, backward compatibility only) for .coderef/ data files.

Production Standard: v2.0.0
- Generated by: coderef-dashboard/packages/coderef-core/src/fileGeneration/saveIndex.ts
- Format: Nested structure with metadata (version, generatedAt, projectPath, totalElements, elements)
- Example: {"version": "2.0.0", "generatedAt": "...", "elements": [...]}

Legacy Format: v1.0.0
- Format: Flat arrays (no version field)
- Example: [{type, name, file, line}, ...]
- Status: Backward compatibility only
"""

import logging
from typing import Any, Dict, List, Union

logger = logging.getLogger(__name__)


def detect_schema_version(data: Union[Dict, List]) -> str:
    """
    Detect the schema version of coderef data.

    Args:
        data: The loaded JSON data (index.json or graph.json)

    Returns:
        str: Schema version ("2.0.0", "v2.0.0", "v1.0.0", or "unknown")

    Schema Detection Logic:
        - v2.0.0 (Production): Has 'version' field in root dict (e.g., "2.0.0" or "v2.0.0")
        - v1.0.0 (Legacy): Is a flat list/array (no version field)
        - unknown: Neither pattern matches
    """
    try:
        # v2.0.0 schema: dict with 'version' field
        if isinstance(data, dict) and 'version' in data:
            version = data.get('version', 'unknown')
            logger.info(f"Detected schema version: {version}")
            return version

        # v1.0.0 schema: flat list/array
        if isinstance(data, list):
            logger.info("Detected schema version: v1.0.0 (flat array)")
            return "v1.0.0"

        # Fallback: unknown
        logger.warning(f"Unknown schema format: {type(data).__name__}")
        return "unknown"

    except Exception as e:
        logger.error(f"Schema version detection failed: {e}")
        return "unknown"


def normalize_index_data(data: Union[Dict, List]) -> List[Dict]:
    """
    Normalize index.json data to v1.0.0 format (flat array) for internal processing.

    Args:
        data: The loaded index.json data (v2.0.0 production or v1.0.0 legacy)

    Returns:
        list: Flat array of code elements (normalized to v1.0.0 format)

    Normalization Rules:
        - v2.0.0 (Production): Extract 'elements' array from nested metadata wrapper
        - v1.0.0 (Legacy): Return as-is (already flat array)
        - unknown: Return empty array + log error
    """
    try:
        schema_version = detect_schema_version(data)

        # v2.0.0: extract elements array (handle both "2.0.0" and "v2.0.0")
        if schema_version.startswith("2.0") or schema_version.startswith("v2.0"):
            elements = data.get('elements', [])
            logger.info(f"Normalized v2.0.0 index data: {len(elements)} elements")
            return elements

        # v1.0.0: already flat array
        if schema_version == "v1.0.0":
            logger.debug(f"Index data already v1.0.0 format: {len(data)} elements")
            return data

        # unknown: return empty array
        logger.error(f"Cannot normalize unknown schema format")
        return []

    except Exception as e:
        logger.error(f"Index data normalization failed: {e}")
        return []


def normalize_graph_nodes(nodes: Union[Dict, List]) -> Dict[str, Any]:
    """
    Normalize graph.json nodes to v1.0.0 format (dict with string keys).

    Args:
        nodes: The nodes field from graph.json

    Returns:
        dict: Nodes as dict with string keys

    Normalization Rules:
        - v2.0.0: Convert list of {id, ...} objects to dict {id: {...}}
        - v1.0.0: Return as-is (already dict)
        - unknown: Return empty dict + log error
    """
    try:
        # v1.0.0: already dict
        if isinstance(nodes, dict):
            logger.debug(f"Graph nodes already v1.0.0 format: {len(nodes)} nodes")
            return nodes

        # v2.0.0: list of {id, ...} objects
        if isinstance(nodes, list):
            normalized = {}
            for node in nodes:
                if isinstance(node, dict) and 'id' in node:
                    node_id = node['id']
                    normalized[node_id] = node
            logger.info(f"Normalized v2.0.0 graph nodes: {len(normalized)} nodes")
            return normalized

        # unknown: return empty dict
        logger.error(f"Cannot normalize nodes of type {type(nodes).__name__}")
        return {}

    except Exception as e:
        logger.error(f"Graph nodes normalization failed: {e}")
        return {}


def normalize_graph_data(data: Union[Dict, List]) -> Dict[str, Any]:
    """
    Normalize entire graph.json data structure to v1.0.0 format.

    Args:
        data: The loaded graph.json data

    Returns:
        dict: Normalized graph data with 'nodes' and 'edges' keys

    Normalization Rules:
        - v2.0.0: Normalize nodes list to dict, keep edges as-is
        - v1.0.0: Return as-is (dict with nodes/edges, no version field)
        - unknown: Return empty structure
    """
    try:
        # Check if this is a v1.0.0 graph (dict with 'nodes' and 'edges', no 'version')
        if isinstance(data, dict) and 'nodes' in data and 'edges' in data and 'version' not in data:
            # v1.0.0: nodes should already be dict
            if isinstance(data['nodes'], dict):
                logger.debug("Graph data already v1.0.0 format")
                return data

        schema_version = detect_schema_version(data)

        # v2.0.0: normalize nodes field (handle both "2.0.0" and "v2.0.0")
        if schema_version.startswith("2.0") or schema_version.startswith("v2.0"):
            nodes = data.get('nodes', [])
            edges = data.get('edges', [])
            normalized_nodes = normalize_graph_nodes(nodes)

            result = {
                'nodes': normalized_nodes,
                'edges': edges
            }
            logger.info(f"Normalized v2.0.0 graph data: {len(normalized_nodes)} nodes, {len(edges)} edges")
            return result

        # unknown: return empty structure
        logger.error("Cannot normalize unknown graph schema format")
        return {'nodes': {}, 'edges': []}

    except Exception as e:
        logger.error(f"Graph data normalization failed: {e}")
        return {'nodes': {}, 'edges': []}


def get_normalized_index(index_path: str) -> List[Dict]:
    """
    Load and normalize index.json file.

    Args:
        index_path: Path to index.json file

    Returns:
        list: Normalized flat array of code elements
    """
    import json
    from pathlib import Path

    try:
        with open(index_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return normalize_index_data(data)
    except Exception as e:
        logger.error(f"Failed to load/normalize index from {index_path}: {e}")
        return []


def get_normalized_graph(graph_path: str) -> Dict[str, Any]:
    """
    Load and normalize graph.json file.

    Args:
        graph_path: Path to graph.json file

    Returns:
        dict: Normalized graph data with 'nodes' and 'edges' keys
    """
    import json
    from pathlib import Path

    try:
        with open(graph_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return normalize_graph_data(data)
    except Exception as e:
        logger.error(f"Failed to load/normalize graph from {graph_path}: {e}")
        return {'nodes': {}, 'edges': []}
